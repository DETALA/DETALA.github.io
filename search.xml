<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/04/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_ptmalloc%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/04/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_ptmalloc%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>源码分析一共分为三个篇章，此篇为第一篇，主要介绍malloc中一些主要的数据结构，为之后第二第三篇的malloc和free的分析进行知识铺垫。</li><li>关于源码的分析皆来自64位的Ubuntu，glibc版本为2.31。</li><li>本篇内容基于<a href="https://cata1oc.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">cataLoc</a>师傅的博客分析（基本都是师傅分析的东西），部分师傅没分析的小函数采用chatgpt进行分析（真好用只能说）。</li></ul><h1 id="堆管理"><a href="#堆管理" class="headerlink" title="堆管理"></a>堆管理</h1><p>Linux提供了两种堆空间分配的方式，一个是brk系统调用，另一个是mmap系统调用。</p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/memspace_1.png" title="" alt="" data-align="center"><p>这时就可以祭出这张经典内存空间的图了，可以看出：</p><ul><li>Heap，向上扩展的内存是由<mark>brk</mark>系统调用分配的堆空间。</li><li>Memory Mapping Segment，向下扩展的内存是由<mark>mmap</mark>分配的，其中包含着文件映射和匿名映射。<em>（这块内存中并不是连续的，其中有着很多空闲空间，mmap分配时就会在这些缝隙中调用）</em></li></ul><h2 id="brk-x2F-sbrk"><a href="#brk-x2F-sbrk" class="headerlink" title="brk&#x2F;sbrk"></a>brk&#x2F;sbrk</h2><ul><li><p>brk简而言之就是指定地址进行扩充</p><p><code>brk()</code> sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory, and the process does not exceed its maximum data size</p></li><li><p>sbrk就是指定要增加的数据大小来进行扩充</p><p><code>sbrk()</code> increments the program’s data space by increment bytes. Calling <code>sbrk()</code> with an increment of 0 can be used to find the current location of the program break.</p></li></ul><h2 id="mmap-x2F-munmmap"><a href="#mmap-x2F-munmmap" class="headerlink" title="mmap&#x2F;munmmap"></a>mmap&#x2F;munmmap</h2><p>看一下函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>mmap()</code>用于在进程的虚拟地址空间中创建一个新的映射，并将文件或设备映射到这块内存中</p><ul><li><p>addr：指定映射的起始地址，若该参数为NULL时，则由操作系统自己决定mapping的起始地址</p></li><li><p>length：指定映射的大小，该值必须大于0</p></li><li><p>prot：描述这段映射的内存保护属性，且不能与打开文件时设置的访问模式相冲突</p></li><li><p>flags：这个字段指定了mapping的一些行为属性，例如是否修改原本被映射的文件，对于映射到同一块区域的其它进程是否可见等等。其中，<strong>当设置了<em>MAP_ANONYMOUS</em>属性后，这块地址空间将不会映射到任何文件，其内容将会被初始化为0，我们称这块空间为匿名（Anonymous）空间，匿名空间可以用来作为堆空间。</strong> 此时，fd参数将会被忽略，offset参数应设置为0</p></li><li><p>fd：指向将被映射到内存中的文件对象</p></li><li><p>offset：被映射内容在文件中的起始偏移，该值必须是页（4KB）的整数倍</p></li></ul></li><li><p><code>munmap</code>则用于删除指定地址范围内的映射</p></li></ul><p>在[cataloc](<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/#mmap-munmap">堆基础01：ptmalloc2初探 | cataLoc’s Blog</a>)师傅的博客中有关于brk和mmap的详细例子，可以直观看到两者的区别和具体在内存的什么位置进行申请，这里不再赘述。</p><h1 id="ptmalloc2分配策略"><a href="#ptmalloc2分配策略" class="headerlink" title="ptmalloc2分配策略"></a>ptmalloc2分配策略</h1><h2 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h2><p>ptmalloc是基于dlmalloc改进，实现了多线程的堆分配器，其中的<code>pt</code>代表着<em>per thread</em>，并随着时间发展为ptmalloc2。</p><p>为了支持多线程并行处理时对于内存的并发请求操作，malloc 的实现中把全局用户堆（heap）划分成很多子堆（sub-heap）。这些子堆是按照循环单链表的形式组织起来的。每一个子堆利用互斥锁（mutex）使线程对于该子堆的访问互斥。当某一线程需要调用 malloc 分配内存空间时，该线程搜索循环链表试图获得一个没有加锁的子堆。如果所有的子堆都已经加锁，那么 malloc 会开辟一块新的子堆，对于新开辟的子堆默认情况下是不加锁的，因此线程不需要阻塞就可以获得一个新的子堆并进行分配操作。在回收 free 操作中，线程同样试图获得待回收块所在子堆的锁，如果该子堆正在被别的线程使用，则需要等待直到其他线程释放该子堆的互斥锁之后才可以进行回收操作。</p><h2 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2><p>ptmalloc2 会在第一次执行 malloc 的时候向操作系统申请 0x21000B（132KB），后续分配就不会向操作系统申请内存，而是会从这块132KB的堆里面进行分割小块，直到用完的时候才会再次申请内存。</p><p>接下来看具体的分配策略，<strong>首先根据申请的字节大小，系统选择一个合适的 chunksize 作为需要分配的 chunk 大小</strong>，这个 chunksize 会通过特定的宏操作计算得出，比方说，<strong>chunksize 至少为 0x20 字节，这个大小的 chunk 最多可以容纳 0x10 字节的数据，那么当申请的空间小于等于 0x10 字节时，ptmalloc2 就会分配一个大小为 0x20 字节的 chunk</strong>。</p><p>这里解释下为什么 chunksize 至少为 0x20 字节，malloc_chunk 本身包含四个字段。</p><ul><li><p>prev_chunksize（8字节）</p></li><li><p>chunksize（8字节）</p></li><li><p>fwd（8字节）</p></li><li><p>bck（8字节）</p></li></ul><p>其中 chunksize 描述的是整个 chunk 的大小，包含这4个字段和数据；另外，当 chunk 被使用时，fwd 和 bck 两个字段是不使用的，因为它们仅在链式管理时使用(<em>当 chunk 放入 bin 中，也意味着这个 chunk 此时是空闲的，暂时不使用了</em>)，当 chunk 正在被使用时，这两个字段是用不到的，自然就可以用来存储数据了，也就是说，原本 malloc_chunk 结构体中两个用来存放指针的空间，可以用来存放数据，大小为 0x10 字节。</p><p><strong>不过，当你申请的大小为0x10和0x18这个范围时，你会发现给你分配的chunk大小依旧为0x20，这是因为，相邻的下一个chunk的头部，prev_chunksize给以给上一个chunk存储数据，因为这个字段是用来存放上一次空闲块的大小，不空闲的话就给他用用，邻里友善了属于是。所以可知，当你申请的chunk对齐后多出来的字节小于等于8字节的话，都是放下一个chunk的prev_chunksize。具体函数分析在下一篇的源码中再谈</strong></p><p>计算出需要分配多大的 chunk 以后，就会开始去不同的 bin 中查找符合条件的 chunk：</p><ol><li>首先是 tcache bin，这是在 glibc2.26 开始引入的缓存机制，默认开启。<strong>如果申请的 chunksize 不属于 large bin，并且 tcache bin 已经初始化了，并且 tcache bin 中有对应的大小的 chunk 块</strong>，那么就会直接从 tcache bin 中取出这个 chunk 拿去用。从 tcache bin 中取出 chunk 的操作是发生在调用<code>_int_malloc()</code>之前的，是最先发生的操作</li><li>接下来会进入<code>_int_malloc()</code>，这是实现 malloc 的核心函数。进入后会先判断 chunksize 是否属于 fast bins，如果属于就去 fast bins 里面找，<strong>fast bins 的判断是严格匹配的，如果 chunksize 是 0x30 字节，那就在 fast bins 中找空闲的 0x30 字节的 chunk。</strong></li><li>fast bins 没有找到合适的，则判断 chunksize 大小是否位于 small bin 的范围区间，如果符合，就会去 small bin 里面找，small bin 包含 62 条 bin 链，和 fast bins 类似，small bin 的每条 bin 链中的 chunk 大小是相同的，因此直接在对应 chunksize 的 bin 链中找就行，同样也是严格匹配 chunksize</li><li>如果在申请的 chunksize 大小位于 large bin 范围区间（或者在 fast bins 和 small bin 中未能找到合适的 chunk），则会先将 fast bins 中的 chunk 合并，插入到 unsorted bin 中，接下来<strong>遍历 unsorted bin 中的所有 chunk，同时将遍历到的 chunk 从 unsorted bin 上摘下，看这个 chunk 的大小是否符合申请的 chunksize，如果符合，就将这个 chunk 返回给用户。否则，就根据这个 chunk 的 chunksize 将其放入 small bin 或者 large bin 中</strong>。但实际从代码来看的话，该流程是找到合适大小符合chunksize的话，会先将其放入tcache中（<em>如果满了直接返回给用户</em>），<code>return_cached</code> 会被设置为1，之后继续遍历剩下的chunk，挨个遍历完后，如果这个过程有找见对于大小的chunk，就会从tcache中拿出返回给用户。</li><li>这里还有一点很重要，在遍历 unsorted chunk 开始处有一个判断条件，<strong>会判断申请的是否为 small chunk（前面判断的 small bin 中的 chunk，这里判断是 unsorted bin 中属于 small bin 范围区间的的 chunk，即尚未分配到 small bin 中的一个 chunk），且 unsorted bin 中只有一个 chunk，且这个 chunk 为 last remainder chunk，且这个 chunk 满足所需的大小加上 0x20</strong>，如果满足这四个条件，则会尝试对这个 last remainder chunk 进行切割，参考下面（6）。切割后剩余的 chunk 仍然作为 last remainder chunk 存在</li><li>接下来，开始在 large bin 中寻找合适的 chunk，由于 large bin 的每个 bin 中的 chunk 大小是不一定相同的，所以在查找时，会先试图找到一个匹配申请的 chunksize 的 chunk。若找不到，就选择一个略微大一些的 chunk，然后<strong>判断这个 chunk 分割出 chunksize 后余下的 remainder chunk 是否能达到最小的 chunksize（即 0x20字节），如果可以达到，那就先分割，把 chunksize 的部分返回给申请的程序。余下的 remainder chunk 则链入 unsorted bin 中，当发生完这个操作后，该 remainder chunk 是最近一次被分割后得到的 chunk，因此又称作 last remainder chunk</strong>；如果 remainder chunk 达不到 0x20 字节，就不分割，把一整块返回给程序</li><li>前面提到的 small bin、unsorted bin、large bin 都属于 bins 中的一个或一组链表，下文会分析到 bins 中各个 bin 的组织结构。</li><li>如果说，在 large bin 中也没找到合适的 chunk，则会通过一个位图判断整个 bins 中是否包含符合申请 chunksize 要求的 bin 链，然后再在这个 bin 链上找是否有符合要求的 chunk，若有的话，则和 （6） 一样根据情况进行分割</li><li>如果 bins 中也没有符合要求的 chunk，则会去 top chunk 进行分割。这个 top chunk 位于一开始申请的 0x21000 字节的高地址处，它不属于任何 bin。如果 top chunk 的大小满足用户所需求的 chunk 大小，那么就会分割一块返回给申请的程序，但是余下的 remainder chunk 不会链入 unsorted bin 中，仍以 top chunk 的形式存在着</li><li>如果 top chunk 仍然不满足申请的 chunksize 需求，那么就会根据实际情况，通过<code>sbrk()</code>扩展 top chunk，或者调用<code>mmap()</code>分配新的堆</li></ol><h1 id="堆管理结构"><a href="#堆管理结构" class="headerlink" title="堆管理结构"></a>堆管理结构</h1><h2 id="分配区"><a href="#分配区" class="headerlink" title="分配区"></a>分配区</h2><p>前面提到，ptmalloc2 在实现多线程时，在 malloc 的实现中把全局用户堆（heap）划分成很多子堆（sub-heap），每一个子堆利用互斥锁使线程对于该子堆的访问互斥。这里 ptmalloc2 引入了 <strong>分配区(arena)</strong> 的概念，每个arena 本质上是完全不同的堆，他们独自管理自己的 chunk 和 bins。arena 分为 main_arena 和 thread_arena。malloc 内部通过<code>brk()</code>和<code>mmap()</code>系统调用来分配内存。每个进程只有一个 main_arena（称为主分配区），但是可以有多个 thread_arena（或者non_main_arena，非主分配区）。</p><ul><li><strong>main_arena</strong>：<ol><li>对应进程 heap 段，由<code>brk()</code>函数创建</li><li>分配区信息由 malloc_state 结构体存储</li><li>main_arena 的 malloc_state 结构体存储在该进程链接的 libc.so 的数据段</li><li>main arena 的大小可以扩展。</li></ol></li><li><strong>thread_arena</strong>：<ol><li>对应进程的 mmap 段，thread_arena 由<code>mmap()</code>函数创建</li><li>分配区信息由 malloc_state 和 heap_info 两个结构体存储</li><li>thread_arena 的 malloc_state 和 heap_info 存放在堆块的头部</li><li>thread_arena 的大小不可以扩展，用完之后需调用<code>mmap()</code>申请一个新的 thread_arena</li></ol></li></ul><h2 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h2><p><strong>heap_info 这个结构相当于 Heap Header</strong>，它是堆的管理结构之一。前面提到了 main_arena 和 thread_arena，其中 main_arena 是不需要 heap_info 结构体的（因为它只有一个堆），所以这里只需要关注它在 thread_arena 中的作用就行了。在非主分配区中是可能包含多个堆的，原因在于 thread_arena 中的堆是通过<code>mmap()</code>调用申请的，因此不能通过<code>brk()</code>进行扩展，当空间不足时，只能够再次调用<code>mmap()</code>申请新的堆空间，heap_info 就是管理这些通过<code>mmap()</code>申请出来的堆空间的，<strong>包括第一次申请的在内，thread_arena 申请的每个堆空间，都会对应一个 heap_info 来描述并管理这个堆</strong></p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/heap_info_1.png" title="" alt="" data-align="center"><ul><li>ar_ptr：这个字段指向堆所在的分配区（arena），是一个 malloc_state 结构体，<strong>一个堆只能对应一个分配区</strong></li><li>prev：将同一个分配区（arena）中，堆的 heap_info 结构，用单向链表链接起来。这里 prev 指向链表中前一个堆对应的 heap_info</li><li>size：当前堆的大小</li><li>mprotect_size：当前堆还没有被分配的内存大小</li><li>pad：用于对齐的，不用关心</li></ul><h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><p><strong>malloc_state 相当于 Arena Header</strong>，前面提到 thread_arena 中的每个堆都对应一个 heap_info，这些所有堆共有一个 malloc_state，它用来<strong>表示分配区，位于整个分配区的头部</strong>。总结一下就是<strong>每个 thread_arena 对应一个 malloc_state，thread_arena 中的每个堆对应一个 heap_info</strong>。当然，malloc_arena 也对应一个 malloc_state，但是存储在该进程链接的 libc.so 的数据段中。</p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/malloc_state_1.png" title="" alt="" data-align="center"><ul><li>mutex：用于串行化访问分配区（arena），当有多个线程访问同一个分配区时，第一个获得这个 mutex 的线程将使用该分配区分配内存，分配完成后，释放该分配区的 mutex，以便其它线程使用该分配区</li><li>flags：记录分配区的一些标志</li><li>have_fastchunks：标志位，判断 fast bin 最近是否有插入空闲块</li><li>fastbinsY：用来记录和管理 fast bin 的链表数组，每条都是单链表</li><li>top：指向 top chunk</li><li>last_remainder：指向 last remainder chunk</li><li>bins：包括 unsorted bin、small bin 和 large bin，具体参考下文介绍 bins 时的图，其中 NBINS 定义为 128</li><li>binmap：用于快速查找对应 index 的 bin 是否为空的一个位图</li><li>next：指向下一个 arena，arena 之间通过单循环链表构成</li><li>next_free：指向下一个空闲的 arena。<strong>这是一个链表（free_list），串着空闲的分配区（free_arena），访问这个链表上的空闲分配区，需要通过 free_list_lock 进行上锁</strong></li><li>attached_threads：附加到当前分配区的线程数。<strong>如果该值为 0，说明没有线程附加到该分配区，此时该分配区位于 free_list</strong>。这个 free_list 就是 next_free 指向的 free_list，它包含着还没有被线程附加的空闲分配区。对于多线程的程序，某个线程申请内存时，会试图从 thread_arena 中获取到分配区，在首次申请时，thread_arena 的尚未被初始化，值为 NULL。此时会进一步调用 <code>get_free_list()</code> 从 free_list 中找到一个尚未被附加的 free_arena 将其返回，同时将该 arena 从 free_list 上移除，并赋值给 thread_arena。这部分在分析<code>__libc_malloc()</code>时会再次提到。</li></ul><h2 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h2><p><strong>malloc_chunk 相当于 Chunk Header</strong>，就是前面提到用来描述一个内存块的结构，chunk 在不同状态下，所使用的字段及含义也不相同，这里以定义时的结构入手进行简单的解析。</p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/malloc_chunk_1.png" title="" alt="" data-align="center"><ul><li>mchunk_prev_size：如果前一个（虚拟内存空间的位置相邻的前一个） chunk 是空闲的，则该字段表示前一个 chunk 的大小（通过当前 chunk 的地址，以及这个字段的值，就可以定位前一个 chunk 的地址，这样在 free 当前 chunk 时，发现前一个 chunk 也是空闲时，就会发生合并）。否则，该字段用于存储前一个 chunk 的数据，没错，<strong>当前一个 chunk 不空闲时，这个字段是不属于当前 chunk 的，而是作为前一个 chunk 的存储空间使用</strong></li><li>mchunk_size：表示当前 chunk 的大小，也记录了当前 chunk 和前一个 chunk 的一些属性</li><li>fd &amp; bk：这俩指针<strong>仅在当前 chunk 空闲时才存在</strong>，用于将 chunk 加入到对应的 bin 中进行统一的链式管理。<strong>若当前 chunk 正在被使用，则这两个指针的位置用于存放数据</strong></li><li>fd_nextsize &amp; bk_nextsize：这俩指针<strong>仅在当前 chunk 空闲时，且位于 large bin 中时才存在</strong>。其中 <strong>fd_nextsize 指向 size 比自身小的里面最大的 chunk，bk_nextsize 指向 size 比自身大的里面最小的 chunk</strong>，这部分可以参考后面 large bin 的图示。</li></ul><h2 id="主分配区和非分配区"><a href="#主分配区和非分配区" class="headerlink" title="主分配区和非分配区"></a>主分配区和非分配区</h2><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/single_heap.png" title="" alt="" data-align="center"><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/multi_heap.png" title="" alt="" data-align="center"><p>第一张图没什么好说的，展示了两者的区别。主要看第二张图发生的变化，在thread arena申请时，如果top chunk不够，由于mmap申请空间不可扩展的性质，这时候会申请新的堆，里面包含着heap_info，没有malloc_state，该结构体一个thread arena只有一个，heap info可以有多个。</p><h2 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h2><p>一个进程全局拥有一个唯一的 malloc_par 实例,主要关注其中记录的关于tcache的信息，在分配时会使用到。</p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/malloc_par_1.png" title="" alt="" data-align="center"><ul><li>trim_threshold：top chunk 的收缩阈值</li><li>top_pad：在分配内存时是否添加额外的 pad，默认设置为0</li><li>mmap_threshold：mmap 分配阈值</li><li>arena_test：当进程的分配区数量小于等于 arena_test 时，不会重用已有的分配区</li><li>arena_max：当进程的分配区数量达到 arena_max 时，不会再创建新的分配区，只会重用已有的分配区</li><li>n_mmaps：当前进程使用 <code>mmap()</code> 分配的内存块的个数</li><li>n_mmaps_max &amp; max_n_mmaps：<code>mmap()</code>函数分配的内存块的最大数量</li><li>no_dyn_threshold：是否开启<code>mmap()</code>分配阈值动态调整机制，默认为0，即开启</li><li>mmaped_mem &amp; max_mmapped_mem：统计<code>mmap()</code>分配的内存大小，通常这两字段的值相等</li><li>sbrk_base：堆的起始地址</li><li>tcache_bins：tcache bin 的数量</li><li>tcache_max_bytes：最大 tcache chunk 的大小</li><li>tcache_count：每个 tcache bin 中 tcache chunk 的最大数量</li></ul><h1 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h1><p> chunk主要就是使用和空闲两种状态。</p><ul><li>已分配的（Allocated chunk）</li><li>空闲的（Free chunk）</li><li>Top chunk</li><li>Last Remainder chunk</li></ul><h2 id="Allocated-chunk"><a href="#Allocated-chunk" class="headerlink" title="Allocated chunk"></a>Allocated chunk</h2><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/allocated_chunk_1.png" title="" alt="" data-align="center"><p>这里唯一需要解释的就是 N、M、P 这三个标志位（这里能余下这 3 位是因为 chunk 大小按照 8 字节对齐）：</p><ul><li>N位：表示是否为 non_main_arena，若为1，则 chunk 属于 thread_arena</li><li>M位：表示该 chunk 是否通过<code>mmap()</code>申请的，若为1，则是</li><li>P位：表示 prev_inuse，若位1，说明前一个（虚拟内存空间的具体位置上的前一个）块正在被使用。即处于 Allocated 状态</li></ul><h2 id="Free-Chunk"><a href="#Free-Chunk" class="headerlink" title="Free Chunk"></a>Free Chunk</h2><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/free_chunk_1.png" title="" alt="" data-align="center"><p>Free Chunk 多出了 fd &amp; bk 这两个指针；若为 largin bin 中的 Free Chunk，则在紧接着fd、bk的地方还会多出 fd_nextsize &amp; bk_nextsize 这俩指针。</p><h2 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h2><p>一个 arena 顶部的 chunk 被称作 top chunk，它不属于任何 bin，其信息<strong>记录在 mstate 中</strong>（即 malloc_state 结构中）。当所有 bin 中都没有空闲可用的 chunk 时，便会切割 top chunk 来满足用户的内存申请。top chunk 在进行分配时也是通过切割，若空间足够，则会从 top chunk 上切割下程序申请大小的 chunk 返回给程序，余下部分，作为新的 top chunk 存在（这个新的 top chunk，在刚分割完时也被称作 last remainder chunk，但不会链入到 unsorted bin 中）。如果连 top chunk 都不够用，则会进行如下判断：</p><ul><li>如果位于 <strong>main_arena</strong> 中，通过<code>brk()/sbrk()</code>扩张 top chunk 的边界</li><li>如果位于 <strong>non_main_arena</strong>（即 thread_arena），则调用<code>mmap()</code>分配新的堆空间，<strong>通过 heap_info 数据结构将多个堆串连在一起</strong></li></ul><p><strong>注意：Top Chunk 的 PREV_INUSE 位总是1</strong></p><h2 id="Last-Remainder-Chunk"><a href="#Last-Remainder-Chunk" class="headerlink" title="Last Remainder Chunk"></a>Last Remainder Chunk</h2><p>Last Remainder Chunk 来源于最近一次的 split（切割） 操作。当程序申请的 mallocsize（这里用 mallocsize 表示程序申请的 chunk 大小） 落入 large bin 对应的范围区间时，若没有找到刚好合适的块，则会选择一个大于 mallocsize 的最小 chunk 进行分配。在分配该块时进行如下判断：</p><ul><li>如果 chunksize - mallocsize &gt;&#x3D; 0x20，则分割出 mallocsize 大小的 chunk 返回给用户，<strong>余下的 chunk 将会链入 unsorted bin 中，这个余下的 chunk，就被称作 last remainder chunk，表示最近一次由于 split 操作从而进入 unsorted bin 的 chunk</strong></li><li>如果 chunksize - mallocsize &lt; 0x20，直接将 chunk 返回给申请的程序，此时不存在 last remainder chunk</li></ul><p>之后当程序再次请求 small chunk 时，且 small chunk 中未能找到合适的 chunk 时，就会判断 last remainder chunk 是否为 unsorted bin 中的唯一块，如果是，那么 last remainder chunk 会被再次分割出 small chunk 返回给程序，余下的部分继续作为新的 last remainder chunk 存在。这样，当程序进行连续的小空间内存申请时，分配到的内存都是相邻的（last remainder chunk 周围） ，从而在 free 的时候就可能会与周围的空闲 small chunk 进行合并操作，达到了更好的局部性</p><h1 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h1><p>bin 是用来管理 free chunk 的链表，根据功能与 chunksize 的不同，可以分为：</p><ul><li>Fast Bin</li><li>Unsorted Bin</li><li>Small Bin</li><li>Large Bin</li><li>Tcache Bin</li></ul><h2 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h2><p>fast bin 顾名思义，当初设计时的定位为 bins 的高速缓冲区，主要用于提高小内存分配效率，放置在 fastbinsY 数组上。当用户释放&#x2F;申请一块不大于 global_max_fast 的 chunk 时，会优先考虑在 fast bin 上存放或从 fast bin 中找到是否存在合适的 chunk。它具备以下特点：</p><ul><li><p>fast bin 采用先进后出（FILO）的原则，每个 bin 只存储大小相同的 chunk，最多包含 10 个bin，范围为 0x20 ~ 0xB0</p></li><li><p>fast bin 是<strong>单向链表（因为它不会从中间摘下一个 chunk 出来，添加与删除只发生在单链表的首尾之间）</strong>，所以只用到了 malloc_chunk 结构的 fd 指针</p></li><li><p>fast bin 中 <strong>chunk 的 prev_inuse 位设为1，即永远被视为在使用中，这意味着相邻空闲 chunk 不会合并</strong>。它的匹配规则也是定量匹配，这在前面介绍分配策略时有提到。虽然这么做导致外部碎片增多，但是 free 效率提升</p></li><li><p>初始化堆时会默认设置 global_max_fast 的值为 0x80，此时 fast bin 只包含 0x20 ~ 0x80 范围的 chunk，大于 0x80 的 chunk 在释放时会进入 unsorted bin。调用 mallopt 设置 fast bin 的最大值，则 fast bin 可以包含最大为 0xB0 的 chunk</p></li></ul><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/fastbin_1.png" title="" alt="" data-align="center"><h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><p>首先 bins 是一个数组，数组中包含了 unsorted bin、small bin 以及 large bin，并且 bins 里面的 bin 都是双链表。</p><ul><li>unsorted bin：<ol><li>是 bins 的缓冲区，位于 bins 数组中的第一位，大小不同且没有限制，FIFO。</li><li><strong>当用户释放的 chunk 大于 global_max_fast 或 fast bin 进行合并后得到的 chunk，都会放入 unsorted bin 中</strong>，因此，unsorted bin 中的 chunk 大小是不同的</li><li>当用户申请的 chunk 在 fast bin 与 small bin 中无法通过定量匹配找到时，会先去 unsorted bin 查找是否有合适的 chunk；若没有，则会将 unsorted bin 上的 chunk 放入 small bin 或 large bin 中，然后再去 large bin 中找</li></ol></li><li>small bin：<ol><li>小于 0x400 字节（64位系统）的 chunk，位于 bins 数组的 2~63 位，共 62 条 small bin，small bin 采用的策略是先进先出（FIFO）</li><li>与 fast bin 类似，<strong>small bin 中每条 bin 存储的 chunk 也是大小相同的；不同的是它会参与合并，因此不存在两个相邻的 free chunk</strong></li><li>small bin 中每条 bin 之间的 chunk 大小相差 0x10 字节</li><li>small bin 起始 bin 的 chunk 大小为 0x20 字节（最大的chunk为1008字节，也就是3F0）</li></ol></li><li>large bin：<ol><li>大于等于0x400 字节（64位系统）的 chunk。位于 bins 数组的 64~126 位，共 63 条 small bin，分配策略复杂，之后具体分析过程时再说。</li><li><strong>large bin 中每条 bin 上的 chunk 大小不一定相同</strong>。大小相同的 chunk 用 fd&#x2F;bk 链接，不相同的用 fd_nextsize&#x2F;bk_nextsize 链接</li><li>每条 bin 之间 chunk 大小相差的字节也是变化的</li></ol></li></ul><h3 id="large-bin大小分析"><a href="#large-bin大小分析" class="headerlink" title="large bin大小分析"></a>large bin大小分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">  (((((unsigned long) (sz)) &gt;&gt; 6) <span class="string">&lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;</span>&gt; 6) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 9) <span class="string">&lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;</span>&gt; 9) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 12) <span class="string">&lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;</span>&gt; 12) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 15) <span class="string">&lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;</span>&gt; 15) :\</span></span><br><span class="line"><span class="meta">   ((((unsigned long) (sz)) &gt;&gt; 18) <span class="string">&lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;</span>&gt; 18) :\</span></span><br><span class="line"><span class="meta">   126)</span></span><br></pre></td></tr></table></figure><p>上面是通过大小寻找large bin下标所定义的宏，它将一个可用chunk的大小（以字节为单位）映射到large bin数组中的一个索引，以便在这个large bin中查找可用的chunk。</p><ol><li><p>如果 sz 右移 6 个比特（即除以 64）得到的结果小于等于 48，则 largebin 索引值为 48 加上这个结果。</p></li><li><p>否则，如果 sz 右移 9 个比特（即除以 512）得到的结果小于等于 20，则 largebin 索引值为 91 加上这个结果。</p></li><li><p>否则，如果 sz 右移 12 个比特（即除以 4096）得到的结果小于等于 10，则 largebin 索引值为 110 加上这个结果。</p></li><li><p>否则，如果 sz 右移 15 个比特（即除以 32768）得到的结果小于等于 4，则 largebin 索引值为 119 加上这个结果。</p></li><li><p>否则，如果 sz 右移 18 个比特（即除以 262144）得到的结果小于等于 2，则 largebin 索引值为 124 加上这个结果。</p></li><li><p>否则，largebin 索引值为 126。</p></li></ol><p>第一个chunk大小为0x400，其他大小具体可以表示为下图</p><img title="" src="https://s2.51cto.com/images/blog/202108/27/25d7ea3cf17b002918d4747656dc3d84.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="" width="468" data-align="center"><h3 id="large-bin结构分析"><a href="#large-bin结构分析" class="headerlink" title="large bin结构分析"></a>large bin结构分析</h3><p>在large bin中同一bin里面的chunk大小属于同一范围，按照从大到小的顺序排列通过fd&amp;bk相连（挨着bin头的为大），这就会形成相同大小的chunk紧紧挨着形成，其中相同大小的chunk中，第一个chunk会通过fd_nextsize &amp; bk_nextsize与下一个不同大小的chunk链接，之后依次，最后一个不同大小的chunk链接第一个chunk。 large bin 是一个<strong>二维双向链表</strong>。</p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_pic_2.png" title="" alt="" data-align="center"><h2 id="Tcache-Bin"><a href="#Tcache-Bin" class="headerlink" title="Tcache Bin"></a>Tcache Bin</h2><p>Tcache 是从 glibc2.26 开始新增的缓存机制，用于优化线程锁竞争的问题，它为每个线程预留了一组 bin，这组 bin 不属于 bins，并具备以下特点：</p><ol><li>tcache bin 中共<strong>包含 64 个 bin</strong>（定义在 TCACHE_MAX_BINS），<strong>每个 bin 中最多缓存 7 个 chunk</strong></li><li>64 位系统上以 0x10 字节递增（24 -&gt; 1032），也就是0x20-&gt;0x410，<strong>注意，0x400和0x410都是large bin的范围</strong>。</li><li>tcache bin 上的 <strong>chunk 的 prev_inuse 设为1</strong>，不会与相邻的空闲 chunk 合并，与 fast bin 类似</li><li>当一个 chunk 被释放时，首先进入 tcache bin，而不是 fast bin，这样当该线程再次申请分配的时候，<strong>如果在其线程 tcache bin 上有空闲 chunk，就从 tcache bin 中取出，无需等待堆锁</strong>，从而实现加速分配。填满了<strong>这个大小</strong>的 tcache bin 后，再释放的 chunk 才会进入 fast bin</li><li>tcache bin 由 tcache_entry 和 tcache_perthread_struct 两个结构体管理</li></ol><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/tcache_1.png" title="" alt="" data-align="center"><p>管理 tcache 的有两个结构，分开看：</p><ul><li>tcache entry：<ul><li>next：位于 malloc_chunk 结构体 fd 指针的位置，指向 bin 中下一个 chunk 的地址（并非直接存储，会进行移位 &amp; 异或，类似 AFL 定位一个基本块的手法）</li><li>key：位于 malloc_chunk 结构体 bk 指针的位置（tcache bin 是单链表，未使用 bk 指针），指向tcache，用来标记 chunk 已在 tcache 中，防止针对 tcache 的 double free 攻击</li></ul></li><li>tcache_perthread_struct：<ul><li>counts：字节数组，TCACHE_MAX_BINS（64）个元素，每个成员用来统计对应下标的 bin 中有多少个 chunk</li><li>entries：指针数组，TCACHE_MAX_BINS（64）个元素，每个成员指向对应下标的 bin 的头节点，其为一个 tcache_entry 结构</li></ul></li></ul><img title="" src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/tcache_2.png" alt="" data-align="inline"><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><p>[堆基础01：ptmalloc2初探](<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">堆基础01：ptmalloc2初探 | cataLoc’s Blog</a>)</p></li><li><p>[堆漏洞挖掘中的bins分类](<a href="https://blog.51cto.com/u_15346415/3675227">堆漏洞挖掘中的bins分类(fastbin、unsorted bin、small bin、large bin)_mb6128aabee41d4的技术博客_51CTO博客</a>)</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/04/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_malloc/"/>
      <url>/2023/04/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_malloc/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇分析了ptmalloc2的分配策略和数据结构，主要介绍了各种bin，这篇将详细分析代码在malloc一个chunk时，是如何实现分配chunk的，我将继续跟随CataLoc师傅的分析继续学习(可以说内容有百分之八十的相似，所以最好直接原帖)。</p><h1 id="libc-mallc主流程"><a href="#libc-mallc主流程" class="headerlink" title="__libc_mallc主流程"></a>__libc_mallc主流程</h1><p>cataLoc师傅编写了一个会使用到 malloc &#x2F; free 的简单程序，用pwndbg进行调试，这里我就直接跟随代码进行分析了，有兴趣了可以看[cataLoc](<a href="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95">堆基础02：malloc源码分析 | cataLoc’s Blog</a>)师傅的源码调试。</p><p>在程序进入malloc函数后，会先执行的函数就是__libc_malloc()，接下来分析总体流程，中间个别函数要简单介绍，在下一部分在进行详细的分析。</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16797370428091679737041892.png"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p><code>mstate ar_ptr</code>，mstate就是malloc_state</p></li><li><p>victim是用来存放chunk的地址，最后函数返回的就是victim</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>静态断言做一个检查，忽略</p></li><li><p>判断否存在 __malloc_hook，若存在则调用该 hook 函数并返回。2.34之后大部分hook已经被删除，包括__malloc_hook；<code>atomic_forced_read(x)</code>相当于<code>*ptr</code>，但是是原子操作。</p></li><li><p>使用tcache机制时：</p><ol><li><p>调用<code>checked_request2size()</code>来判断申请空间大小是否合法，在 64 位的情况下，bytes 不能大于 0x7fffffffffffffff；合法该函数会返回<strong>需要分配的chunk大小</strong>，保存到<strong>tbytes</strong>参数中返回。</p></li><li><p>调用<code>csize2tidx()</code>*(chunk size-&gt;tcache index)*，根据tbytes的chunk大小找见<strong>tcache bin下标</strong>，存放到变量<code>tc_idx</code>。</p></li><li><p><code>MAYBE_INIT_TCACHE</code>，如果tcache未初始化，则会调用<code>tcache_init()</code>来初始化 tcache</p></li><li><p>进行if判断，如果三个条件都满足则调用<code>tcache_get()</code>来获取<code>tc_idx</code>下标对应bin的第一个chunk；条件如下：</p><ul><li><p>判断下标是否在tcache bins范围内（mp_对应malloc_par）</p></li><li><p>判断tcache是否存在</p></li><li><p>判断下标对应的tcache bin中是否有空闲tcache chunk</p></li></ul></li></ol></li></ul><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_4.png"></p><ul><li><p>单线程情况下：</p><ol><li><p>调用<code>_int_malloc()</code>函数分配内存，参数分别为<code>main_arena</code>和<code>bytes</code>，前者因为单线程，所以肯定是主分配区，如果第一次申请会在<code>_int_malloc()</code>中初始化，后者为用户申请的字符数。</p></li><li><p><code>assert</code>这里进行了一个检测，大概意思是，如果victim存在，且是从mmap分配的，而且还是从主分配区分配的则发出中止，因为主分配区都是<code>brk()</code>或者<code>sbrk()</code>生成的。里面函数基本都能从字母意思理解到，不做解释了，其中<code>mem2chunk</code>会在之后分析。</p></li></ol></li><li><p>多线程情况下：</p><ol><li><p>首先调用<code>arena_get()</code>获取分配区</p></li><li><p>调用<code>_int_malloc()</code>从该分配区中拿到分配给的内存地址</p></li><li><p>如果<code>victim</code>不存在且<code>ar_ptr</code>存在，也就是chunk获取失败，分配区获取成功的情况下，<strong>可能是 mmap 区域的内存耗尽等多种原因</strong>。所以这里会调用<code>arena_get_retry()</code>更换分配区，然后再调用<code>_int_malloc</code>从新的分配区上进行分配。<em>LIBC_PROBE宏定义：添加自定义的跟踪代码，memory_malloc_retry 是一个全局变量，用于控制在内存分配过程中的重试次数。</em>（不重要，但是有疑惑了可以看看）</p></li><li><p>获取分配区的话，需要将线程锁释放，这个锁是在获取分配区的时候上的。</p></li><li><p>返回<code>victim</code>给用户</p></li></ol></li></ul><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>处理hook（2.34删了）-&gt;申请tcache的chunk-&gt;单线程或多线程（调用_int_malloc）</p><h1 id="libc-malloc辅助函数"><a href="#libc-malloc辅助函数" class="headerlink" title="__libc_malloc辅助函数"></a>__libc_malloc辅助函数</h1><p>64位系统下的一些数据类型的大小：</p><table><thead><tr><th align="center">数据类型</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">size_t</td><td align="center">0x8</td></tr><tr><td align="center">Size_SZ</td><td align="center">0x8</td></tr></tbody></table><p>一些宏的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这三个宏定义在源码中经常能看到，其实它不会改编程序逻辑，只是告诉编译器这个很可能为某个值，就</span></span><br><span class="line"><span class="comment">// 把否的情况作为跳转，真的情况就顺序运行下去，减少程序的跳转，一定程度上可以优化程序运行速度。</span></span><br><span class="line"><span class="comment">// 或者还有一个简单粗暴的办法，你把这三个字符全都去了，不影响代码逻辑。</span></span><br><span class="line">__glibc_unlikely(<span class="built_in">exp</span>): 表示<span class="built_in">exp</span>很可能为假</span><br><span class="line">__glibc_likely(<span class="built_in">exp</span>): 表示<span class="built_in">exp</span>很可能为真</span><br><span class="line">__builtin_expect(<span class="built_in">exp</span>, value): 表示<span class="built_in">exp</span>==value大概率成立</span><br></pre></td></tr></table></figure><h2 id="checked-request2size"><a href="#checked-request2size" class="headerlink" title="checked_request2size"></a>checked_request2size</h2><img title="" src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_1.png" alt="" data-align="center" width="519"><ul><li><p>如果用户申请大小大于 <code>PTRDIFF_MAX</code>——64位下 0x7fffffffffffffff，直接返回错误</p></li><li><p>大小合法的话就调用<code>request2size()</code>这个宏，计算出需要分配的 chunk 大小返回给 sz，并返回 true</p></li></ul><h3 id="request2size"><a href="#request2size" class="headerlink" title="request2size()"></a>request2size()</h3><p>由于<code>request2size()</code>属于宏，我就不另起标题了。</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_2.png"></p><ul><li><p>MALLOC_ALIGNMENT 是 2 个 SIZE_SZ 的大小，就是 0x10 字节</p></li><li><p>MALLOC_ALIGN_MASK 就是 15 字节，也就是 0xF</p></li><li><p>MIN_CHUNK_SIZE 是从 malloc_chunk 结构体开头，到 fd_nextsize 这个字段之前的大小，也就是 4个 SIZE_SZ，共 32 字节，即 0x20</p></li><li><p>MINSIZE 根据计算可得为 0x20 字节</p></li></ul><p>可以看出该宏就是进行一个判断，req加上<code>SIZE_SZ</code>和<code>MALLOC_ALIGN_MASK</code>后与<code>MINSIZE</code>进行比较，小于则直接返回MINSIZE，否则就在相加结果的基础上进行对齐，也就是与0xF0进行按位与操作。我正常来想会这么设计代码，判断最后一位(16进制)是否小于等于8字节，是的话最后一位补全成8字节，然后加0x10，不是的话最后一位消除成0，加0x20。但是源码设计的就极为巧妙。</p><h2 id="csize2tidx"><a href="#csize2tidx" class="headerlink" title="csize2tidx"></a>csize2tidx</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/csize2tidx_1.png"></p><ul><li><p>这里的参数 x，正是前<code>request2size()</code>这个宏计算出的实际需要分配的 chunk 大小</p></li><li><p>MALLOC_ALIGNMENT 是 2 个 SIZE_SZ 的大小，就是 0x10 字节</p></li><li><p>MINSIZE 前面也算出来是 0x20 字节</p></li></ul><p>该函数就是通过chunk大小来寻找tcache对应bin的下标，因为tcache的增长大小为0x10，所以除以<code>MALLOC_ALIGNMENT</code>，tcache最小chunk就是<code>MINSIZE</code>大小，所以减去，而且下标从0开始。</p><h2 id="MAYBE-INIT-TCACHE"><a href="#MAYBE-INIT-TCACHE" class="headerlink" title="MAYBE_INIT_TCACHE"></a>MAYBE_INIT_TCACHE</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_init_1.png"></p><p>可以看到在<code>MAYBE_INIT_TCACHE</code>内，如果tcache为null时调用了tcache_init()</p><h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h3><p>所以直接来看<code>tcache_init</code>：</p><ol><li>首先计算出 tcache_perthread_struct 结构的大小，然后为其分配空间</li><li>调用<code>arena_get()</code>获取分配区，通过<code>_int_malloc()</code>分配内存给victim</li><li>如果分配区存在但没分配到，即victim为0，那就调用<code>arena_get_retry()</code>换个分配区再调用<code>tcache_init</code>分配</li><li>分配完成后调用<code>__libc_lock_unlock</code>释放分配区，这是因为在获取分配区或者更换分配区时会进行上锁操作</li><li>最后将申请到的内存赋给 tcache_perthread_struct 结构，再调用<code>memset()</code>将内容初始化为0</li></ol><h2 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_get_1.png"></p><p>在获取tcache下标后，就可以根据下标取出tcache对应bin中的第一个chunk，这就是tcache_get的用处。</p><ul><li>先根据 idx 找到对应的 tcache bin 的第一个 tcache_entry，也就是这条 bin 上的第一个 chunk 块</li><li>将这条 tcache bin 上的第一个 tcache_entry 修改为当前 tcache_entry 的下一个 tcache_entry，相当于将原先第一个 tcache_entry 给取出来</li><li>修改此 tcache_bin 对应 tcache_counts 中表示该链上 chunk 数量的值，执行减 1 操作</li><li>将取出的 chunk 的 key 字段置为 NULL，表示已经从 tcache 上取出；最后将其返回</li></ul><h2 id="chunk-is-mmapped"><a href="#chunk-is-mmapped" class="headerlink" title="chunk_is_mmapped"></a>chunk_is_mmapped</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk_is_mmapped_1.png"></p><ul><li>这个宏就是判断当前这个 chunk 是否通过<code>mmap()</code>申请的，这部分在<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>介绍 malloc_chunk 时有提到，在 chunksize 的低 3 位保存了当前 chunk 的一些属性，其中下标为1的位（10b）就是用于判断 IS_MAPPED 的 M 位</li></ul><h2 id="chunk2mem-x2F-mem2chunk"><a href="#chunk2mem-x2F-mem2chunk" class="headerlink" title="chunk2mem &#x2F; mem2chunk"></a>chunk2mem &#x2F; mem2chunk</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk2mem_1.png"></p><p>通过回想malloc_chunk的结构，chunk一般指向prev_size的位置，mem指向fd，所以这两个宏的功能就显而易见了，通过加减0x10来进行转换，一般来说，用户申请获取的chunk的指针都是指向mem的，在系统中一般使用指向chunk的指针，除了tcache bin，它也直接指向next指针的位置。</p><h2 id="arena-for-chunk"><a href="#arena-for-chunk" class="headerlink" title="arena_for_chunk"></a>arena_for_chunk</h2><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16804287997791680428799208.png"></p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16804287297801680428729489.png"></p><p>上面的函数定义在arena.c中，下方还是在malloc.c</p><ul><li><code>arena_for_chunk</code>是用来获取 chunk 所在的分配区（arena）的，如果调用<code>chunk_main_arena</code>判断出不是主分配区则通过<code>heap_for_ptr</code>找见该chunk的<code>heap_info</code>，进而从<code>heap_info</code>找见指向的arena。</li><li><code>chunk_main_arena</code>，看一下<code>NON_MAIN_ARENA</code>位是否被设置，这个值若未设置，就可以直接判断出是 main_arena（主分配区）</li><li><code>heap_for_ptr</code>，计算 HEAP_MAX_SIZE - 1 取反后的值，将其与 chunk 所在地址进行与操作，从而得到 chunk 所在堆的 heap_info 地址。</li></ul><p>关于为什么可以这样获取heap_info的地址，且在后续how2heap进阶篇的最后一个手法——mmap_overlapping_chunks中，也需要理解这一点，那就是在thread_arena中，<strong>堆的申请是<code>HEAP_MAX_SIZE </code>对齐的，且复习ptmalloc2初窥中的图片可以看出，heap_info是在堆的开头</strong>，所以只需要找到chunk所属heap的头地址就好了。</p><h2 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_1.png"></p><ul><li><strong>arena_get</strong>：<ul><li>直接从 thread_arena 获取分配区（主分配区的获取不使用<code>arena_get()</code>），该变量会线程开始时被初始化，每一个线程都有自己的一份变量副本，而不是共享。</li><li>将获取到的分配区和申请内存大小作为参数传入 <code>arean_lock()</code></li></ul></li><li><strong>arena_lock</strong>：<ul><li>判断是否成功获取分配区，若成功获取，则调用<code>__libc_lock_lock</code>对分配区上锁</li><li>若获取失败，则调用<code>arena_get2()</code>重新获取分配区，失败的话</li></ul></li><li><strong>arena_get2</strong>：<ul><li>调用<code>get_free_list()</code>获取分配区，如果获取成功则将分配区返回，这里<code>get_free_list()</code>返回的是 malloc_state 结构体，失败了则会分配新的arena。<em>（if(a&#x3D;&#x3D;NULL)）中将代码缩略了，如果想了解详细过程可以问一下chatgpt，分析的很详细。</em></li></ul></li><li><strong>get_free_list</strong>：<ul><li>这里的 replaced_arena 是给下面要分析的<code>arena_get_retry()</code>用的，调用<code>arena_get()</code>时这个值通常为 NULL</li><li>先获取 free_list 上的第一个空闲分配区（free_arena），这是一个串着所有空闲分配区的链表，然后将其从 free_list 上摘下来</li><li>摘下来后，修改分配区的 attached_threads 的值为1，表明该分配区附加到当前线程；如果是通过<code>arena_get_retry</code>调用的，则还会将线程与原先的分配区（replaced_arena）进行 detach 操作；最后将新获取的分配区返回</li></ul></li></ul><h2 id="arena-get-retry"><a href="#arena-get-retry" class="headerlink" title="arena_get_retry"></a>arena_get_retry</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_retry_1.png"></p><p>结合在tcache_init中调用情况来看，如果arena_get获取了分配区，但是没有从中分配空间给victim，两种可能，对于main_arena来说是sbrk失败()；thread_arena是mmap()失败，那么就需要调用该函数了。</p><ul><li>如果arena_get()返回的arena是非主分配区，说明没有进行mmap()，可以考虑试着从主分配区分配；否则，就又调用<code>arena_get2()</code>。</li></ul><h1 id="int-malloc-主流程"><a href="#int-malloc-主流程" class="headerlink" title="_int_malloc 主流程"></a>_int_malloc 主流程</h1><h2 id="初始校验"><a href="#初始校验" class="headerlink" title="初始校验"></a>初始校验</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/int_malloc_1.png"></p><ul><li><p><code>_int_malloc()</code>接收两个参数，分配区和需要分配的大小，然后从分配区中分配满足需求大小的 chunk</p></li><li><p>变量中需要注意，mchunkptr 与 mbinptr 类型均是 malloc_chunk 结构体</p></li><li><p>进入函数后最先会遇到两处校验：</p><ol><li><code>checked_request2size()</code>前面分析过了，这里主要是判断申请的内存大小是否超过了边界，若未超过，则会计算出至少需要分配的 chunksize，将值保存到 nb 中，然后进入下一个判断</li><li>接下来会判断 av 也就是传入的分配区是否为空，通常不为空。但如果为空，就会调用<code>sysmalloc()</code>去请求一个 chunk，通过<code>alloc_perturb()</code>初始化后，将这个 chunk 返回。这里 perturb_byte 的值默认为 0</li></ol></li></ul><h2 id="Fast-Bin-处理流程"><a href="#Fast-Bin-处理流程" class="headerlink" title="Fast Bin 处理流程"></a>Fast Bin 处理流程</h2><p>从这开始进入了关键流程的分析，大致流程就是依次从fast bin、small bin、unsorted bin和large bin寻找符合大小的chunk，除了large bin中可以切割chunk来返回给用户，只有在unsorted bin中满足特殊条件时可以切割剩下的最后一个chunk，当然，其中还夹杂着将fast bin中chunk进行合并的操作。</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fastbin_part_2.png"></p><p>直接套用Cataloc师傅的图进行分析，通过方框划分代码分析逻辑很清晰。开头<code>REMOVE_FB</code>宏不做解释了，实现单向链表删除第一个 node 的操作。</p><p>之后进入fast bin的if判断，大小是否小于fast bin的最大值，是的话进入fast bin的处理流程</p><p><strong>红色方框（if条件：大小符合fast bin大小）：</strong></p><ul><li>先通过<code>fastbin_index</code>算出 idx，即所需的 chunk 位于哪条 bin 上</li><li>调用<code>fastbin</code>获取对应 bin 的链表头，并将链表上的第一个 chunk 地址赋给 victim</li><li>判断 vicitim 是否存在，若不存在，说明这条 bin 上已经没有多余的 chunk 了，又<strong>因为 fast bin 中是大小严格匹配的</strong>，如果大小符合的 chunk 不存在，也不会去寻找其它的 bin，就会直接跳过 fast bin 剩余的处理逻辑</li></ul><p><strong>橙色方框（if条件：idx对应bin上存在空闲chunk）：</strong></p><ul><li>取出该chunk，单线程则直接取下，bin头的fd指向chunk的fd；多线程采用开头定义的<code>REMOVE_FB</code>将chunk取出单链。</li></ul><p><strong>蓝色方框（if条件：victim不为空）：</strong></p><ul><li>这部分主要是两个 check，第一个 check 是用 vicitim 再算一遍，判断其是否属于它原先所在的 bin</li><li>第二个 check 是对一些标志位的 check</li></ul><p><strong>粉色方框（if条件：开启tcache bin）：</strong></p><ul><li>首先根据申请的 chunk 的大小，计算出当前 fast bin 对应的 tcache bin 是哪一个</li><li>先将找到的第一个符合要求的 chunk 作为 victim 暂存，并从 fast bin 上摘下，接下来从这条找到符合要求 chunk 的 fast bin 里面继续找，<strong>如果这个 fast bin 不为空，且 tcache bin 仍有多余空间（少于 7 个 chunk）</strong>，那么会通过一个循环将 fast bin 中的剩余 chunk 移动到 tcache bin 中，每轮循环都会判断一次 fast bin 是否还有 chunk 以及 tcache bin 是否还有空间（这个过程也是 fastbin-reverse-into-tcache 这个利用手法的核心）。从 fast bin 摘下来的操作和前面橙色方框中的一样；放入 tcache bin 中则是用的 <code>tcache_put</code></li><li>这里多解释一下，fast bin和tcache bin中取下放入都是头部，因为都是单链表结构。所以从fast bin拿出放入tcache bin中后，链表顺序会被反转，所以reverse是这个意思。</li></ul><p><strong>绿色方框：</strong></p><ul><li>拿到 vicitim 后，调用<code>chunk2mem</code>将指针指向 chunk 存储数据的开始地址</li><li>再调用<code>alloc_perturb()</code>对这块内存初始化，然后返回给用户</li></ul><p><strong>总结</strong></p><p>fast bin处理中主要就是寻找对应大小idx，通过下标获取该bin的第一个chunk，并将剩余同大小的chunk放入tcache bin中，最后返回给用户chunk。</p><h2 id="Small-Bin-处理流程"><a href="#Small-Bin-处理流程" class="headerlink" title="Small Bin 处理流程"></a>Small Bin 处理流程</h2><p>fast bin中不符合的话，就进入下一个判断，是否符合small bin的大小范围。</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16805152531081680515252539.png"></p><p>可以看出，首先是判断申请的 chunksize 范围是否在 small bin 的范围内，然后在整个处理流程中穿插了黄框内tcache bin的处理过程。</p><p><strong>红色方框：</strong></p><ul><li><p>开头</p><ul><li><p>先调用<code>smallbin_index</code>算出 chunk 所在的 idx 是多少</p></li><li><p>再调用<code>bin_at</code>得到 idx 在 bins 中对应的那个 bin 的链表头。</p></li></ul></li><li><p>if判断</p><ul><li><p>第一个if（蓝色大括号，接下来代码都属于该蓝色大括号内容），判断这个链表头的后一个元素是否还是它自己（<strong>注意这里在判断的同时，也进行了赋值操作，此时该链表若至少存在 1 个 chunk，那么 vicitim 指向的就是这个 chunk 的地址</strong>），是的话说明是空的，进入下一类bin的判断。</p></li><li><p>获取victim的bk，也就是上一个chunk地址赋值给bck</p></li><li><p>if判断链条的完整性，bck的下一个chunk是否是victim，不是的话报错</p></li><li><p>通过<code>set_inuse_bit_at_offset</code>将 victim 之后（进程虚拟内存中紧挨着 victim 地址的 chunk）的一个 chunk 的 prev_inuse 设置为 1，表示 victim 这个 chunk 正在被使用。fast bin 处理过程中是没有这个操作的，因为 fast bin 中的 chunk 默认都设置了 prev_inuse 的值，从而防止 chunk 之间的前后合并</p></li><li><p>然后进行一个脱链操作，<strong>注意，small bin和unsorted bin都是头进尾出。</strong></p></li><li><p>if判断这个 chunk 的分配区是否为主分配区，若是，则设置相应字段的值</p></li><li><p>接着调用<code>check_malloced_chunk</code>进行一些字段的检查</p></li></ul></li></ul><p><strong>黄色方框：</strong></p><p>这部分代码都是启用tcache bin时才会执行的部分。总体和fast bin的部分功能相同，这里只介绍一些不同的地方。</p><ul><li><p>small bin 中的 chunk 放入 tcache bin 中时需要设置 prev_inuse；fast bin 中的 chunk 默认是设置了的</p></li><li><p>small bin 断链进行的是双链表操作；fast bin 是单链表操作</p></li><li><p>small bin 需要判断是否为主分配区，并设置相应字段；fast bin 没有</p></li></ul><p><strong>红色方框：</strong></p><p>这部分和fast bin相同，将分配的好的 chunk 初始化后返回给用户</p><h2 id="Unsorted-Bin-处理流程"><a href="#Unsorted-Bin-处理流程" class="headerlink" title="Unsorted Bin 处理流程"></a>Unsorted Bin 处理流程</h2><p>如果在 small bin 或者 fast bin 处理流程中找到了合适大小的 chunk，那么程序就返回了。<strong>如果执行到这里，说明 chunk 大小位于 large bin 中或者在 small bin 和 fast bin 中没有找到所需大小的块</strong></p><h3 id="idx赋值"><a href="#idx赋值" class="headerlink" title="idx赋值"></a>idx赋值</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_1.png"></p><p>这个else是对应前面的<code>if (in_smallbin_range(nb))</code>，所以说明chunk大小属于large bin</p><ul><li><p>通过宏<code>largebin_index</code>获取所需 chunk 在 large bin 中的 index，即所在的 bin 链</p></li><li><p>判断 fast bin 是否存在（即是否已经初始化），若存在，则调用<code>malloc_consolidate()</code>将 fast bin 中的所有 chunk free 掉并与前后的块合并，然后存到 unsorted bin 中</p></li></ul><p>从else出来后，又会进入有关tcache bin的处理，</p><ul><li>调用<code>csize2tidx</code>获取所需 chunk 大小在 tcache bin 中的 idx，如果 nb 的大小位于 tcache 范围内（tcache 范围涵盖了 large bin 中的前面一小部分），则将其赋值给变量 tcache_nb，且将两个变量进行赋值0，之后会讲到，这里先略过。</li></ul><h3 id="for头检查"><a href="#for头检查" class="headerlink" title="for头检查"></a>for头检查</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_2.png"></p><p>进入了超大的for循环，一直到__int_malloc结束，开头进行了轮数的初始化为0，用来在while循环进行判断，该while循环持续到unsorted bin结束：</p><ul><li><p>括号进行了赋值和判断，victim 表示当前 chunk，不等于bin头的话就说明不为空</p></li><li><p><strong>bck 为 unsorted bin 上 victim 的上一个 chunk，next 为 victim 的下一个 chunk</strong></p></li><li><p>然后进行五个if判断，分别为：</p><ul><li><p>前两个if检查 victim 和 next 的 size 不能小于最小的 chunksize，也不能大于所属分配区已经分配的内存大小（<strong>这里不知道为什么是大小0x10，而不是MINSZIE0x20</strong>）</p></li><li><p>检查 next 的 prev_size 是否等于 victim 的 size</p></li><li><p>检查 victim-&gt;bk-&gt;fd 是否等于 victim，保证双链表完整性；检查 victim-&gt;fd 是否等于 unsorted_chunks(av) 这是因为在每轮循环开始有 <code>victim = unsorted_chunks(av)-&gt;bk</code></p></li><li><p>检查 victim 是否设置了 prev_inuse，因为进入 unsorted bin 中的 chunk 都已经清空了该值</p></li></ul></li></ul><h3 id="last-reminder"><a href="#last-reminder" class="headerlink" title="last reminder"></a>last reminder</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_3.png"></p><p>这里是单独讨论一种特殊情况</p><p>在if中需要满足四个条件：</p><ol><li><p><strong>所需 chunk 的大小的范围在 small bin 中</strong></p></li><li><p>unsorted bin 中仅剩最后一个 chunk</p></li><li><p>victim是last remainder chunk，下面是之前对于这两个变量的赋值，回忆一下</p><ul><li><code>bck = victim-&gt;bk</code></li><li><code>victim = unsorted_chunks(av)-&gt;bk</code></li></ul></li><li><p>该 last remainder chunk 的 size 需大于所需 chunk 大小与 MINSIZE 之和</p></li></ol><p>之后就是进行一次 chunk 切割的操作，把所需大小的 chunk 返回给用户，余下的部分作为 last remainder chunk 回到 unsorted bin 中：</p><ol><li><strong>计算出 remainder_size，然后通过<code>chunk_at_offset</code>拿到分割后 remainder 的地址</strong></li><li>修改 unsorted bin 的fd和bk，将其指向 last remainder chunk 的位置</li><li>成为新的 last remainder chunk</li><li>将reminder的bk和fd指向unsorted bin的bin头</li><li><strong>如果 remainder 大小不在 small bin 范围内</strong>，就添加 fd_nextsize 与 bk_nextsize 指针</li><li>设置 victim 与 remainder 的标志位</li><li>将 victim 存储数据的地址（victim + 2*SIZE_SZ）返回给用户</li></ol><h3 id="into-tcache"><a href="#into-tcache" class="headerlink" title="into_tcache"></a>into_tcache</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_4.png"></p><p>首先 check 一下链表的完整性，校验成功后，会将当前的 chunk 也就是 victim 从 unsorted bin 上面摘下来，方便后续操作</p><p>然后判断一下，如果 victim 的 size 刚好符合申请所需的 chunk 大小，那么先设置好标志位，然后：</p><ul><li>如果开启了 tcache（glibc2.31中默认开启），并且<strong>victim size 对应的 tc_idx 所在 bin 中仍有空余位置</strong>（少于7个），那么就调用<code>tcache_put()</code>将 victim 放入到 tcache 中，且将<strong>return_cached置为1</strong>，<strong>表示找到过符合大小的chunk</strong>且放入了tcache。</li><li>如果对应的这条 tcache bin 已经满了，那么就直接将其返回给用户</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_5.png"></p><p>这步是 unsorted bin 处理的核心，它会将 unsorted bin 中遍历的 chunk 根据 size 放入对应的 small bin 或者 large bin 中，这是唯一一次将 chunk 放入 small bin 或者 large bin 的过程。</p><p>如果 vicitim 的 size 位于 small bin：</p><ol><li>获取该 size 在 small bin 中的 index</li><li>bck等于index 所在 bin 的头指针</li><li>fwd等于头指针后的第一个 chunk 指针</li><li>使用头插法将 victim 插入到 bck 与 fwd 之间的位置，相当于末尾（图片右下角四行代码）</li></ol><p>否则，即 victim 的 size 位于 large bin 时：</p><ol><li><p>获取该 size 在 large bin 中的 index</p></li><li><p>获取该 index 所在 bin 的头指针作为 bck</p></li><li><p>获取头指针后的第一个 chunk 指针作为 fwd，<strong>这里的第一个 chunk 可以理解为这条 bin 链上 size 最大的 chunk之一</strong>，相当于下图的size为132的chunk。</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_pic_2.png"></p></li></ol><p>接下来3833到3879内都是讨论chunk的大小，用来与bin中最大chunk和最小的chunk进行比较，主要用来设置large bin特有的fd_nextsize和bd_nextsize，bk和fd在最后统一设置。我采用和Cataloc师傅一样的讲述逻辑，不按照执行顺序来，这部分必须了解清楚large bin的结构是怎么样的才好理解。</p><ol><li><p><strong>fwd &#x3D;&#x3D; bck</strong></p><ul><li>这部分对应着3877-3878这两行，如果bin为空的话，直接设置victim的fd_nextsize 与 bk_nextsize成自己</li></ul></li><li><p><strong>fwd !&#x3D; bck 且 victim_size &lt; size（bck-&gt;bk）</strong></p><ul><li><p>这部分对应着3840-3849行，情况为chunk大小&lt;最小的chunk大小，为了方便，<strong>接下来我会用大fd和大bk来指代fd_nextsize和bd_nextsize</strong>。</p></li><li><p>可以看到这部分就是单纯在大fd、bk链条中插入了victim，我们只需要搞清这个位置在哪，以及如何进行查找的即可，位置不用多想，加进来一个最小的chunk肯定是在末尾，所以小bk和fd直接和前末尾chunk相连，而大fd和bk和最小的这群chunk的第一个相连。</p></li><li><p>首先看if中bck-&gt;bk查找到的chunk，是通过小bk找见的，所以是最小的chunk之一，且是这群chunk中的最后一个chunk。</p></li><li><p><code>fwd = bck</code>，<code>bck = bck-&gt;bk</code>， 现在fwd指向bin的头指针，bck为整条链的最后一个chunk（最后四行代码会将victim插入fwd和bck之间）。</p></li><li><p><code>victim-&gt;fd_nextsize = fwd-&gt;fd;</code> victim的<strong>大fd</strong>指向<strong>链表上第一个chunk</strong>（上图的第一个132大小的chunk）<br><code>victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</code>victim的<strong>大bk</strong>指向<strong>最小chun链表的第一个chunk</strong>(size为120chunk)</p></li><li><p><code>fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code></p><p><strong>链表上第一个chunk的大bk</strong>和<strong>最小chun链表的第一个chunk的大fd</strong>都指向victim。</p></li></ul></li></ol><p>接下来3850到3858是通过wihle循环，通过大fd来从前往后，寻找第一个不大于victim_size的chunk，找到之后就判断等于和小于两种情况。</p><ol start="3"><li><p><strong>fwd !&#x3D; bck 且 victim_size &#x3D;&#x3D; fwd_size</strong></p><ul><li><p>对应3859-3862,很显然，如果存在该大小的chunk了，那就没必要设置大fd和bk，直接获取该大小chunk群的第二个chunk保存到fwd。</p></li><li><p>这里就注意，如果是插入已存在的chunk大小群，是放着这群chunk的第二个的位置，这也很好理解，放第一个还得设置大fd和bk，多此一举了。</p></li></ul></li><li><p><strong>fwd !&#x3D; bck 且 victim_size &gt; fwd_size</strong></p><ul><li><p>对应3864-3871行。</p></li><li><p>很明显victm的<strong>大fd</strong>指向<strong>这个第一个小于它本身的chunk</strong>（小c），<strong>大bk</strong>指向<strong>这个小c的大bk</strong>，也就是<strong>上一个大于小c的chunk群的第一个chunk</strong>。</p></li><li><p>检查一下<strong>链表完整性</strong></p></li><li><p><strong>小c的大bk</strong>指向<strong>victim</strong>，将<strong>victim的上个大chunk</strong>指向<strong>victim自己</strong>。</p></li></ul><p>这部分说起来很绕，但是自己去设计插入的角度理解，就很快能看懂了，建议把自己当作编写代码的人员，这部分你会怎么写。</p><p>3872-3875这部分，是属于3、4情况之后都会执行的，对bck赋值等于fwd-&gt;bk，方面最后四行代码的链表插入，将victim插入bck和fwd之间。且进行了一次<strong>链表完整性检查</strong>。</p></li></ol><p>最后的四行代码已经多次提到，主要说倒数第五行，<code>mark_bin()</code>主要标记该bin不为空，因为刚刚放进去了一个chunk，肯定不为空了。</p><h3 id="tcache处理"><a href="#tcache处理" class="headerlink" title="tcache处理"></a>tcache处理</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_6.png"></p><p>这部分是整个部分的末尾。</p><p><strong>红色方框：</strong></p><ul><li><p>如果执行过上面<strong>分类</strong>的代码就会走到这里，所以必然没有将符合大小chunk放到tcache bin中，这样的话，tcache_unsorted_count就表示没放入tcache bin中的chunk的数目，进行+1。</p></li><li><p>如果之前把chunk放到过tcache bin（<strong>return_cached&#x3D;1</strong>），开启了<code>tcache_unsorted_limit</code>（默认是 0），且<code>tcache_unsorted_count</code>大于了<code>tcache_unsorted_limit</code> 的值，就会调用 <code>tcache_get()</code>从 tcache bin 中取出符合需求的 chunk 返回给用户。（这部分一般不执行）</p></li></ul><p><strong>绿色方框：</strong></p><p>注意这部分有个大括号，闭合了前面的 while 循环，<strong>最多遍历 unsorted bin 一万次</strong>。不然一次产生了太多的 unsorted bin，然后我 malloc 一次，结果一直在这个循环里分配 unsorted bin 上面的 chunk，迟迟等不到分配的内存，所以这里会设定一个遍历的最大值</p><p><strong>蓝色方框</strong>：</p><p>最后，出了 while 循环，也就遍历完 unsorted bin 了，这时会判断一下在先前遍历时是否找到符合需求的 chunk，若找到了且被放入了 tcache bin 中，则 return_cached 会被设置，此时调用<code>tcache_get()</code>即可。至此，unsorted bin 的处理逻辑就全部结束了。若仍未找到合适的 chunk，则会继续往后执行。</p><h2 id="Large-Bin-处理流程"><a href="#Large-Bin-处理流程" class="headerlink" title="Large Bin 处理流程"></a>Large Bin 处理流程</h2><h3 id="通过idx寻找"><a href="#通过idx寻找" class="headerlink" title="通过idx寻找"></a>通过idx寻找</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_1.png"></p><p><strong>第一层校验</strong>会判断所需的 chunk 大小 nb 是否位于 small bin 范围内，这里再判断一遍的原因是 <code>bin_at</code>这个宏是根据 size 获取在 bins 中的 idx 的，<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>我们提到，bins 中包含了 unsorted bin，small bin 以及 large bin。这里又判断一次范围是否在 small bin 也是为了确保，<code>bin_at</code> 的结果会落在 large bin 在 bins 对应的 idx 范围内</p><p><strong>第二层校验</strong>是确保 large bin 不为空，且 large bin 中最大的 chunk 要比所需的 chunk 要大。<code>first</code>宏用于获取 idx 所在 bin 中第一个 chunk，即当前 idx 中最大的 chunk赋值给victim。</p><p>接下来开始在 large bin 中寻找到最合适的那个 chunk，逻辑如下：</p><ol><li>与插入 chunk 到 large bin 中不同，这里是从最小的 chunk 开始遍历，直到找到一个 chunk 大于等于所需的 chunk 大小</li><li>这里有两处判断，第二处<strong>用来确保 victim 所在的相同大小的双链上至少有两个 chunk</strong>，这样我们方便把第二个 chunk，也就是 victim-&gt;fd 给分配出去。<code>victim != last(bin)</code>主要是判断该链上是否就只有一个 chunk。</li><li>如果这条链上存在至少 2 个 chunk，那就取第 2 个，否则就用第 1 个。然后调用<code>unlink_chunk()</code>将这个 chunk 断链，并判断切去所需大小 nb 后，余下空间是否构成一个最小 chunk：<ul><li>若不能，则对这个 chunk 设置并检查相应的标志位后，返回给用户</li><li>若能，则会切割出 nb 大小的部分，余下的部分作为 remainder 链入到 unsorted bin 中并根据大小决定是否设置 bk_nextsize &#x2F; fd_nextsize，并对 remainder 与分割出的部分分别设置标志位，将分割出的部分返回给用户。<strong>此处分割剩下的 remainder，并没有被设置为该分配区的 last remainder chunk。分析到这里为止，仅在 unsorted bin 处理逻辑中的一次分割会设置 last remainder chunk，这点需要注意</strong>。</li></ul></li></ol><h3 id="通过binmap寻找"><a href="#通过binmap寻找" class="headerlink" title="通过binmap寻找"></a>通过binmap寻找</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_2.png"></p><ul><li><p><code>++idx</code>：在前一个 bins[idx] 所表示的 large bin 中没有找到合适的块，那么就增加 idx 的值，去 bins[idx++] 去找是否有符合的块。当然，理论上 bins[idx++] 中只要存在 chunk，就一定可以满足需求</p></li><li><p><code>bin_at</code>：这个宏之前已经多次出现，就是<strong>拿到这个 idx 在 bins 对应的链表的头节点</strong>，这个头节点是一个 malloc_chunk 结构体，通过头节点的 fd&#x2F;bk 指针可以访问这个 bin 上的第一个块（对应 large bin 中最大的块）与最后一块（对应 large bin 中最小的块）</p></li><li><p>接下来 3 行相互之间有所关联，需要放在一起来看：</p><ul><li><p>首先 block，map，bit 这三个变量都是 unsigned int 类型</p></li><li><p>malloc_state 结构中有一个 binmap，它用来快速查找对应 index 所在的 bin 是否为空。这里通过 av-&gt;binmap 来访问</p></li><li><p>binmap 是个数组，长度为 4，每个元素都是一个 32 位的整数，加起来刚好是 128 位，刚好对应 bins 中的每个 bin，这 128 位可以看作是下标，若该下标的值置0，则说明 bin 为空</p></li><li><p><code>idx2block</code> 这个宏的操作是将 idx 右移 5位，即将 idx 除 32，得到一个位于 0~3 范围内的值，从而找到该下标位于 binmap 中的第几个 32 位的整数上</p></li><li><p><code>idx2bit</code> 作用是取到 idx 对应 large bin 的下标</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/idx2bit.png"></p></li></ul></li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>该循环持续到large bin处理的结尾，这里分两部分讲解。</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_3.png"></p><ul><li><p>if 语句有两个条件：</p><ul><li><p>bit &gt; map：如果bit大于map说明在本block中，该map32位中，高于bit位的位置都为0，表示对应的bin都为空，无需继续检查</p></li><li><p>bit &#x3D;&#x3D; 0：通过idx2bit转化为32位的数据中，应该是31个0和一个1组成的，所以bit!&#x3D;0；</p></li></ul></li><li><p>然后进入循环，判断当前 block 的值是否为 0，即这个 block 所表示的 32 个 bin 是否都是空的，如果是空的，就找下一个 block。如果全部都为空，就跳转到后面的 use_top 中进行处理。如果不为空，那么找到该block对应的第一个bin并将 bit 置 1（0···01表示该block的第一个bin）。</p></li><li><p>while 循环里通过 bit 与 map 相与是否为 0 来判断这个 bin 是否为空。若为空，则通过<code>next_bin</code>来访问下一个 bin，这里的下一个可以理解为 <code>bins[80] -&gt; bins[81]</code> 这种形式，同时 bit 也进行左移，即移动到这个 block 里面与表示这个 bin 所在位置的下标处。</p></li><li><p>此时这个 bin 应该不是空的，但还是要判断一下。通过 <code>last</code> 获取到 bin 中的第一个元素，判断是否与自身相等，若相等，则说明 bin 为空，那么将这个 bin 在 binmap 中对应的 bit 置零，然后继续查看下一个 bin</p></li></ul><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_4.png"></p><ul><li><p>若不为空，直接使用victim进行分割，因为上面赋值的是last(bin)，也就上该bin上最小的chunk。</p></li><li><p>接下来的操作就和 unsorted bin 里面满足 4 个条件的那个操作，以及前面在一开始就可以找到一个合适的 large bin chunk 时的操作是类似的。就是先切割，挂到 unsorted bin 中，返回给用户这么几个操作，这里就不多赘述了。</p></li><li><p>唯一需要注意的是，<strong>若所需的 chunk 位于 small bin 的范围</strong>（在large bin处理的开头判断过一次，范围只持续在第一部分——通过idx寻找），<strong>那么这里分割后的 remainder 会被设置为 last remainder chunk。这是第二次设置 last remainder chunk 的地方。</strong></p></li></ul><h2 id="Top-Chunk-处理流程"><a href="#Top-Chunk-处理流程" class="headerlink" title="Top Chunk 处理流程"></a>Top Chunk 处理流程</h2><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/1680534109697use_top.png"></p><ul><li>先通过 av-&gt;top 获取到 top chunk，通过宏 <code>chunksize</code> 获取到 top chunk 的大小。然后先做一个判断，看这个 top chunk 的 size 是否超过了 av-&gt;system_mem（这个值表示系统调用时申请的内存大小）。这个判断在 unsorted bin 的处理流程开始处也进行过一次</li><li>接下来，则根据 top chunk 的情况分类处理：<ul><li>如果 top chunk 超过 nb（所需 chunk 大小） + MINSIZE，那么操作和前面 unsorted bin 与 large bin 分割类似。<strong>此处分割不会设置 last remainder chunk</strong></li><li>否则，如果存在 fastbin，那么先调用 <code>malloc_consolidate()</code> 将 fastbin 合并；再根据所需的 chunk 大小设置 idx 的值，然后回到死循环的开头（图中紫色大括号，对应 unsorted bin 处理流程的开始部分）再进行一轮判断</li><li>若上面俩都没执行，那么调用 <code>sysmalloc()</code> 通过系统调用来进行内存分配，这部分可参考<a href="https://www.cnblogs.com/luoleqi/p/15520621.html#sysmalloc-internal_size_t-nb-mstate-av">Pwnki</a>的分析</li></ul></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><p>[堆基础02：malloc源码分析](<a href="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">堆基础02：malloc源码分析 | cataLoc’s Blog</a>)</p></li><li><p>[glibc 2.31 malloc与free 源码分析](<a href="https://www.cnblogs.com/luoleqi/p/15520621.html#sysmalloc-internal_size_t-nb-mstate-av">glibc 2.31 malloc与free 源码分析（持续更新） - PwnKi - 博客园</a>)</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
