<!DOCTYPE html><html class="appearance-auto" lang="zh-cn"><head><meta charset="UTF-8"><title>DATAL's blog</title><meta name="description" content="my blogs about pwn"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="前言上一篇分析了ptmalloc2的分配策略和数据结构，主要介绍了各种bin，这篇将详细分析代码在malloc一个chunk时，是如何实现分配chunk的，我将继续跟随CataLoc师傅的分析继续学习(可以说内容有百分之八十的相似，所以最好直接原帖)。
__libc_mallc主流程cataLoc师傅编写了一个会使用到 malloc &amp;#x2F; free 的简单程序，用pwndbg进行调试，这里我就直接跟随代码进行分析了，有兴趣了可以看[cataLoc](堆基础02：malloc源码分析 | cataLoc’s Blog)师傅的源码调试。
在程序进入malloc函数后，会先执行的函数就是__libc_malloc()，接下来分析总体流程，中间个别函数要简单介绍，在下一部分在进行详细的分析。

变量
mst.."><meta name="generator" content="Hexo 6.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">DATAL's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center"></p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#libc-mallc%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-text">__libc_mallc主流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">总体流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#libc-malloc%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-text">__libc_malloc辅助函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checked-request2size"><span class="toc-text">checked_request2size</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#request2size"><span class="toc-text">request2size()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#csize2tidx"><span class="toc-text">csize2tidx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAYBE-INIT-TCACHE"><span class="toc-text">MAYBE_INIT_TCACHE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-init"><span class="toc-text">tcache_init</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-get"><span class="toc-text">tcache_get</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chunk-is-mmapped"><span class="toc-text">chunk_is_mmapped</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chunk2mem-x2F-mem2chunk"><span class="toc-text">chunk2mem &#x2F; mem2chunk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arena-for-chunk"><span class="toc-text">arena_for_chunk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arena-get"><span class="toc-text">arena_get</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arena-get-retry"><span class="toc-text">arena_get_retry</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#int-malloc-%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-text">_int_malloc 主流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%A0%A1%E9%AA%8C"><span class="toc-text">初始校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fast-Bin-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">Fast Bin 处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Small-Bin-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">Small Bin 处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsorted-Bin-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">Unsorted Bin 处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#idx%E8%B5%8B%E5%80%BC"><span class="toc-text">idx赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%A4%B4%E6%A3%80%E6%9F%A5"><span class="toc-text">for头检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#last-reminder"><span class="toc-text">last reminder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#into-tcache"><span class="toc-text">into_tcache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache%E5%A4%84%E7%90%86"><span class="toc-text">tcache处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Large-Bin-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">Large Bin 处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87idx%E5%AF%BB%E6%89%BE"><span class="toc-text">通过idx寻找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87binmap%E5%AF%BB%E6%89%BE"><span class="toc-text">通过binmap寻找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-text">for循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Top-Chunk-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">Top Chunk 处理流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle"></h1><time class="has-text-grey" datetime="2023-04-09T13:54:03.673Z">2023-04-09</time><article class="mt-2 post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇分析了ptmalloc2的分配策略和数据结构，主要介绍了各种bin，这篇将详细分析代码在malloc一个chunk时，是如何实现分配chunk的，我将继续跟随CataLoc师傅的分析继续学习(可以说内容有百分之八十的相似，所以最好直接原帖)。</p>
<h1 id="libc-mallc主流程"><a href="#libc-mallc主流程" class="headerlink" title="__libc_mallc主流程"></a>__libc_mallc主流程</h1><p>cataLoc师傅编写了一个会使用到 malloc &#x2F; free 的简单程序，用pwndbg进行调试，这里我就直接跟随代码进行分析了，有兴趣了可以看[cataLoc](<a target="_blank" rel="noopener" href="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95">堆基础02：malloc源码分析 | cataLoc’s Blog</a>)师傅的源码调试。</p>
<p>在程序进入malloc函数后，会先执行的函数就是__libc_malloc()，接下来分析总体流程，中间个别函数要简单介绍，在下一部分在进行详细的分析。</p>
<p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16797370428091679737041892.png"></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p><code>mstate ar_ptr</code>，mstate就是malloc_state</p>
</li>
<li><p>victim是用来存放chunk的地址，最后函数返回的就是victim</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>静态断言做一个检查，忽略</p>
</li>
<li><p>判断否存在 __malloc_hook，若存在则调用该 hook 函数并返回。2.34之后大部分hook已经被删除，包括__malloc_hook；<code>atomic_forced_read(x)</code>相当于<code>*ptr</code>，但是是原子操作。</p>
</li>
<li><p>使用tcache机制时：</p>
<ol>
<li><p>调用<code>checked_request2size()</code>来判断申请空间大小是否合法，在 64 位的情况下，bytes 不能大于 0x7fffffffffffffff；合法该函数会返回<strong>需要分配的chunk大小</strong>，保存到<strong>tbytes</strong>参数中返回。</p>
</li>
<li><p>调用<code>csize2tidx()</code>*(chunk size-&gt;tcache index)*，根据tbytes的chunk大小找见<strong>tcache bin下标</strong>，存放到变量<code>tc_idx</code>。</p>
</li>
<li><p><code>MAYBE_INIT_TCACHE</code>，如果tcache未初始化，则会调用<code>tcache_init()</code>来初始化 tcache</p>
</li>
<li><p>进行if判断，如果三个条件都满足则调用<code>tcache_get()</code>来获取<code>tc_idx</code>下标对应bin的第一个chunk；条件如下：</p>
<ul>
<li><p>判断下标是否在tcache bins范围内（mp_对应malloc_par）</p>
</li>
<li><p>判断tcache是否存在</p>
</li>
<li><p>判断下标对应的tcache bin中是否有空闲tcache chunk</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/libc_malloc_4.png"></p>
<ul>
<li><p>单线程情况下：</p>
<ol>
<li><p>调用<code>_int_malloc()</code>函数分配内存，参数分别为<code>main_arena</code>和<code>bytes</code>，前者因为单线程，所以肯定是主分配区，如果第一次申请会在<code>_int_malloc()</code>中初始化，后者为用户申请的字符数。</p>
</li>
<li><p><code>assert</code>这里进行了一个检测，大概意思是，如果victim存在，且是从mmap分配的，而且还是从主分配区分配的则发出中止，因为主分配区都是<code>brk()</code>或者<code>sbrk()</code>生成的。里面函数基本都能从字母意思理解到，不做解释了，其中<code>mem2chunk</code>会在之后分析。</p>
</li>
</ol>
</li>
<li><p>多线程情况下：</p>
<ol>
<li><p>首先调用<code>arena_get()</code>获取分配区</p>
</li>
<li><p>调用<code>_int_malloc()</code>从该分配区中拿到分配给的内存地址</p>
</li>
<li><p>如果<code>victim</code>不存在且<code>ar_ptr</code>存在，也就是chunk获取失败，分配区获取成功的情况下，<strong>可能是 mmap 区域的内存耗尽等多种原因</strong>。所以这里会调用<code>arena_get_retry()</code>更换分配区，然后再调用<code>_int_malloc</code>从新的分配区上进行分配。<em>LIBC_PROBE宏定义：添加自定义的跟踪代码，memory_malloc_retry 是一个全局变量，用于控制在内存分配过程中的重试次数。</em>（不重要，但是有疑惑了可以看看）</p>
</li>
<li><p>获取分配区的话，需要将线程锁释放，这个锁是在获取分配区的时候上的。</p>
</li>
<li><p>返回<code>victim</code>给用户</p>
</li>
</ol>
</li>
</ul>
<h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>处理hook（2.34删了）-&gt;申请tcache的chunk-&gt;单线程或多线程（调用_int_malloc）</p>
<h1 id="libc-malloc辅助函数"><a href="#libc-malloc辅助函数" class="headerlink" title="__libc_malloc辅助函数"></a>__libc_malloc辅助函数</h1><p>64位系统下的一些数据类型的大小：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">size_t</td>
<td align="center">0x8</td>
</tr>
<tr>
<td align="center">Size_SZ</td>
<td align="center">0x8</td>
</tr>
</tbody></table>
<p>一些宏的定义：</p>
<pre><code class="c">// 这三个宏定义在源码中经常能看到，其实它不会改编程序逻辑，只是告诉编译器这个很可能为某个值，就
// 把否的情况作为跳转，真的情况就顺序运行下去，减少程序的跳转，一定程度上可以优化程序运行速度。
// 或者还有一个简单粗暴的办法，你把这三个字符全都去了，不影响代码逻辑。
__glibc_unlikely(exp): 表示exp很可能为假
__glibc_likely(exp): 表示exp很可能为真
__builtin_expect(exp, value): 表示exp==value大概率成立
</code></pre>
<h2 id="checked-request2size"><a href="#checked-request2size" class="headerlink" title="checked_request2size"></a>checked_request2size</h2><img title="" src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_1.png" alt="" data-align="center" width="519">

<ul>
<li><p>如果用户申请大小大于 <code>PTRDIFF_MAX</code>——64位下 0x7fffffffffffffff，直接返回错误</p>
</li>
<li><p>大小合法的话就调用<code>request2size()</code>这个宏，计算出需要分配的 chunk 大小返回给 sz，并返回 true</p>
</li>
</ul>
<h3 id="request2size"><a href="#request2size" class="headerlink" title="request2size()"></a>request2size()</h3><p>由于<code>request2size()</code>属于宏，我就不另起标题了。</p>
<p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/request2size_2.png"></p>
<ul>
<li><p>MALLOC_ALIGNMENT 是 2 个 SIZE_SZ 的大小，就是 0x10 字节</p>
</li>
<li><p>MALLOC_ALIGN_MASK 就是 15 字节，也就是 0xF</p>
</li>
<li><p>MIN_CHUNK_SIZE 是从 malloc_chunk 结构体开头，到 fd_nextsize 这个字段之前的大小，也就是 4个 SIZE_SZ，共 32 字节，即 0x20</p>
</li>
<li><p>MINSIZE 根据计算可得为 0x20 字节</p>
</li>
</ul>
<p>可以看出该宏就是进行一个判断，req加上<code>SIZE_SZ</code>和<code>MALLOC_ALIGN_MASK</code>后与<code>MINSIZE</code>进行比较，小于则直接返回MINSIZE，否则就在相加结果的基础上进行对齐，也就是与0xF0进行按位与操作。我正常来想会这么设计代码，判断最后一位(16进制)是否小于等于8字节，是的话最后一位补全成8字节，然后加0x10，不是的话最后一位消除成0，加0x20。但是源码设计的就极为巧妙。</p>
<h2 id="csize2tidx"><a href="#csize2tidx" class="headerlink" title="csize2tidx"></a>csize2tidx</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/csize2tidx_1.png"></p>
<ul>
<li><p>这里的参数 x，正是前<code>request2size()</code>这个宏计算出的实际需要分配的 chunk 大小</p>
</li>
<li><p>MALLOC_ALIGNMENT 是 2 个 SIZE_SZ 的大小，就是 0x10 字节</p>
</li>
<li><p>MINSIZE 前面也算出来是 0x20 字节</p>
</li>
</ul>
<p>该函数就是通过chunk大小来寻找tcache对应bin的下标，因为tcache的增长大小为0x10，所以除以<code>MALLOC_ALIGNMENT</code>，tcache最小chunk就是<code>MINSIZE</code>大小，所以减去，而且下标从0开始。</p>
<h2 id="MAYBE-INIT-TCACHE"><a href="#MAYBE-INIT-TCACHE" class="headerlink" title="MAYBE_INIT_TCACHE"></a>MAYBE_INIT_TCACHE</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_init_1.png"></p>
<p>可以看到在<code>MAYBE_INIT_TCACHE</code>内，如果tcache为null时调用了tcache_init()</p>
<h3 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h3><p>所以直接来看<code>tcache_init</code>：</p>
<ol>
<li>首先计算出 tcache_perthread_struct 结构的大小，然后为其分配空间</li>
<li>调用<code>arena_get()</code>获取分配区，通过<code>_int_malloc()</code>分配内存给victim</li>
<li>如果分配区存在但没分配到，即victim为0，那就调用<code>arena_get_retry()</code>换个分配区再调用<code>tcache_init</code>分配</li>
<li>分配完成后调用<code>__libc_lock_unlock</code>释放分配区，这是因为在获取分配区或者更换分配区时会进行上锁操作</li>
<li>最后将申请到的内存赋给 tcache_perthread_struct 结构，再调用<code>memset()</code>将内容初始化为0</li>
</ol>
<h2 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tcache_get_1.png"></p>
<p>在获取tcache下标后，就可以根据下标取出tcache对应bin中的第一个chunk，这就是tcache_get的用处。</p>
<ul>
<li>先根据 idx 找到对应的 tcache bin 的第一个 tcache_entry，也就是这条 bin 上的第一个 chunk 块</li>
<li>将这条 tcache bin 上的第一个 tcache_entry 修改为当前 tcache_entry 的下一个 tcache_entry，相当于将原先第一个 tcache_entry 给取出来</li>
<li>修改此 tcache_bin 对应 tcache_counts 中表示该链上 chunk 数量的值，执行减 1 操作</li>
<li>将取出的 chunk 的 key 字段置为 NULL，表示已经从 tcache 上取出；最后将其返回</li>
</ul>
<h2 id="chunk-is-mmapped"><a href="#chunk-is-mmapped" class="headerlink" title="chunk_is_mmapped"></a>chunk_is_mmapped</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk_is_mmapped_1.png"></p>
<ul>
<li>这个宏就是判断当前这个 chunk 是否通过<code>mmap()</code>申请的，这部分在<a target="_blank" rel="noopener" href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>介绍 malloc_chunk 时有提到，在 chunksize 的低 3 位保存了当前 chunk 的一些属性，其中下标为1的位（10b）就是用于判断 IS_MAPPED 的 M 位</li>
</ul>
<h2 id="chunk2mem-x2F-mem2chunk"><a href="#chunk2mem-x2F-mem2chunk" class="headerlink" title="chunk2mem &#x2F; mem2chunk"></a>chunk2mem &#x2F; mem2chunk</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/chunk2mem_1.png"></p>
<p>通过回想malloc_chunk的结构，chunk一般指向prev_size的位置，mem指向fd，所以这两个宏的功能就显而易见了，通过加减0x10来进行转换，一般来说，用户申请获取的chunk的指针都是指向mem的，在系统中一般使用指向chunk的指针，除了tcache bin，它也直接指向next指针的位置。</p>
<h2 id="arena-for-chunk"><a href="#arena-for-chunk" class="headerlink" title="arena_for_chunk"></a>arena_for_chunk</h2><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16804287997791680428799208.png"></p>
<p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16804287297801680428729489.png"></p>
<p>上面的函数定义在arena.c中，下方还是在malloc.c</p>
<ul>
<li><code>arena_for_chunk</code>是用来获取 chunk 所在的分配区（arena）的，如果调用<code>chunk_main_arena</code>判断出不是主分配区则通过<code>heap_for_ptr</code>找见该chunk的<code>heap_info</code>，进而从<code>heap_info</code>找见指向的arena。</li>
<li><code>chunk_main_arena</code>，看一下<code>NON_MAIN_ARENA</code>位是否被设置，这个值若未设置，就可以直接判断出是 main_arena（主分配区）</li>
<li><code>heap_for_ptr</code>，计算 HEAP_MAX_SIZE - 1 取反后的值，将其与 chunk 所在地址进行与操作，从而得到 chunk 所在堆的 heap_info 地址。</li>
</ul>
<p>关于为什么可以这样获取heap_info的地址，且在后续how2heap进阶篇的最后一个手法——mmap_overlapping_chunks中，也需要理解这一点，那就是在thread_arena中，<strong>堆的申请是<code>HEAP_MAX_SIZE </code>对齐的，且复习ptmalloc2初窥中的图片可以看出，heap_info是在堆的开头</strong>，所以只需要找到chunk所属heap的头地址就好了。</p>
<h2 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_1.png"></p>
<ul>
<li><strong>arena_get</strong>：<ul>
<li>直接从 thread_arena 获取分配区（主分配区的获取不使用<code>arena_get()</code>），该变量会线程开始时被初始化，每一个线程都有自己的一份变量副本，而不是共享。</li>
<li>将获取到的分配区和申请内存大小作为参数传入 <code>arean_lock()</code></li>
</ul>
</li>
<li><strong>arena_lock</strong>：<ul>
<li>判断是否成功获取分配区，若成功获取，则调用<code>__libc_lock_lock</code>对分配区上锁</li>
<li>若获取失败，则调用<code>arena_get2()</code>重新获取分配区，失败的话</li>
</ul>
</li>
<li><strong>arena_get2</strong>：<ul>
<li>调用<code>get_free_list()</code>获取分配区，如果获取成功则将分配区返回，这里<code>get_free_list()</code>返回的是 malloc_state 结构体，失败了则会分配新的arena。<em>（if(a&#x3D;&#x3D;NULL)）中将代码缩略了，如果想了解详细过程可以问一下chatgpt，分析的很详细。</em></li>
</ul>
</li>
<li><strong>get_free_list</strong>：<ul>
<li>这里的 replaced_arena 是给下面要分析的<code>arena_get_retry()</code>用的，调用<code>arena_get()</code>时这个值通常为 NULL</li>
<li>先获取 free_list 上的第一个空闲分配区（free_arena），这是一个串着所有空闲分配区的链表，然后将其从 free_list 上摘下来</li>
<li>摘下来后，修改分配区的 attached_threads 的值为1，表明该分配区附加到当前线程；如果是通过<code>arena_get_retry</code>调用的，则还会将线程与原先的分配区（replaced_arena）进行 detach 操作；最后将新获取的分配区返回</li>
</ul>
</li>
</ul>
<h2 id="arena-get-retry"><a href="#arena-get-retry" class="headerlink" title="arena_get_retry"></a>arena_get_retry</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/arena_get_retry_1.png"></p>
<p>结合在tcache_init中调用情况来看，如果arena_get获取了分配区，但是没有从中分配空间给victim，两种可能，对于main_arena来说是sbrk失败()；thread_arena是mmap()失败，那么就需要调用该函数了。</p>
<ul>
<li>如果arena_get()返回的arena是非主分配区，说明没有进行mmap()，可以考虑试着从主分配区分配；否则，就又调用<code>arena_get2()</code>。</li>
</ul>
<h1 id="int-malloc-主流程"><a href="#int-malloc-主流程" class="headerlink" title="_int_malloc 主流程"></a>_int_malloc 主流程</h1><h2 id="初始校验"><a href="#初始校验" class="headerlink" title="初始校验"></a>初始校验</h2><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/int_malloc_1.png"></p>
<ul>
<li><p><code>_int_malloc()</code>接收两个参数，分配区和需要分配的大小，然后从分配区中分配满足需求大小的 chunk</p>
</li>
<li><p>变量中需要注意，mchunkptr 与 mbinptr 类型均是 malloc_chunk 结构体</p>
</li>
<li><p>进入函数后最先会遇到两处校验：</p>
<ol>
<li><code>checked_request2size()</code>前面分析过了，这里主要是判断申请的内存大小是否超过了边界，若未超过，则会计算出至少需要分配的 chunksize，将值保存到 nb 中，然后进入下一个判断</li>
<li>接下来会判断 av 也就是传入的分配区是否为空，通常不为空。但如果为空，就会调用<code>sysmalloc()</code>去请求一个 chunk，通过<code>alloc_perturb()</code>初始化后，将这个 chunk 返回。这里 perturb_byte 的值默认为 0</li>
</ol>
</li>
</ul>
<h2 id="Fast-Bin-处理流程"><a href="#Fast-Bin-处理流程" class="headerlink" title="Fast Bin 处理流程"></a>Fast Bin 处理流程</h2><p>从这开始进入了关键流程的分析，大致流程就是依次从fast bin、small bin、unsorted bin和large bin寻找符合大小的chunk，除了large bin中可以切割chunk来返回给用户，只有在unsorted bin中满足特殊条件时可以切割剩下的最后一个chunk，当然，其中还夹杂着将fast bin中chunk进行合并的操作。</p>
<p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/fastbin_part_2.png"></p>
<p>直接套用Cataloc师傅的图进行分析，通过方框划分代码分析逻辑很清晰。开头<code>REMOVE_FB</code>宏不做解释了，实现单向链表删除第一个 node 的操作。</p>
<p>之后进入fast bin的if判断，大小是否小于fast bin的最大值，是的话进入fast bin的处理流程</p>
<p><strong>红色方框（if条件：大小符合fast bin大小）：</strong></p>
<ul>
<li>先通过<code>fastbin_index</code>算出 idx，即所需的 chunk 位于哪条 bin 上</li>
<li>调用<code>fastbin</code>获取对应 bin 的链表头，并将链表上的第一个 chunk 地址赋给 victim</li>
<li>判断 vicitim 是否存在，若不存在，说明这条 bin 上已经没有多余的 chunk 了，又<strong>因为 fast bin 中是大小严格匹配的</strong>，如果大小符合的 chunk 不存在，也不会去寻找其它的 bin，就会直接跳过 fast bin 剩余的处理逻辑</li>
</ul>
<p><strong>橙色方框（if条件：idx对应bin上存在空闲chunk）：</strong></p>
<ul>
<li>取出该chunk，单线程则直接取下，bin头的fd指向chunk的fd；多线程采用开头定义的<code>REMOVE_FB</code>将chunk取出单链。</li>
</ul>
<p><strong>蓝色方框（if条件：victim不为空）：</strong></p>
<ul>
<li>这部分主要是两个 check，第一个 check 是用 vicitim 再算一遍，判断其是否属于它原先所在的 bin</li>
<li>第二个 check 是对一些标志位的 check</li>
</ul>
<p><strong>粉色方框（if条件：开启tcache bin）：</strong></p>
<ul>
<li>首先根据申请的 chunk 的大小，计算出当前 fast bin 对应的 tcache bin 是哪一个</li>
<li>先将找到的第一个符合要求的 chunk 作为 victim 暂存，并从 fast bin 上摘下，接下来从这条找到符合要求 chunk 的 fast bin 里面继续找，<strong>如果这个 fast bin 不为空，且 tcache bin 仍有多余空间（少于 7 个 chunk）</strong>，那么会通过一个循环将 fast bin 中的剩余 chunk 移动到 tcache bin 中，每轮循环都会判断一次 fast bin 是否还有 chunk 以及 tcache bin 是否还有空间（这个过程也是 fastbin-reverse-into-tcache 这个利用手法的核心）。从 fast bin 摘下来的操作和前面橙色方框中的一样；放入 tcache bin 中则是用的 <code>tcache_put</code></li>
<li>这里多解释一下，fast bin和tcache bin中取下放入都是头部，因为都是单链表结构。所以从fast bin拿出放入tcache bin中后，链表顺序会被反转，所以reverse是这个意思。</li>
</ul>
<p><strong>绿色方框：</strong></p>
<ul>
<li>拿到 vicitim 后，调用<code>chunk2mem</code>将指针指向 chunk 存储数据的开始地址</li>
<li>再调用<code>alloc_perturb()</code>对这块内存初始化，然后返回给用户</li>
</ul>
<p><strong>总结</strong></p>
<p>fast bin处理中主要就是寻找对应大小idx，通过下标获取该bin的第一个chunk，并将剩余同大小的chunk放入tcache bin中，最后返回给用户chunk。</p>
<h2 id="Small-Bin-处理流程"><a href="#Small-Bin-处理流程" class="headerlink" title="Small Bin 处理流程"></a>Small Bin 处理流程</h2><p>fast bin中不符合的话，就进入下一个判断，是否符合small bin的大小范围。</p>
<p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/16805152531081680515252539.png"></p>
<p>可以看出，首先是判断申请的 chunksize 范围是否在 small bin 的范围内，然后在整个处理流程中穿插了黄框内tcache bin的处理过程。</p>
<p><strong>红色方框：</strong></p>
<ul>
<li><p>开头</p>
<ul>
<li><p>先调用<code>smallbin_index</code>算出 chunk 所在的 idx 是多少</p>
</li>
<li><p>再调用<code>bin_at</code>得到 idx 在 bins 中对应的那个 bin 的链表头。</p>
</li>
</ul>
</li>
<li><p>if判断</p>
<ul>
<li><p>第一个if（蓝色大括号，接下来代码都属于该蓝色大括号内容），判断这个链表头的后一个元素是否还是它自己（<strong>注意这里在判断的同时，也进行了赋值操作，此时该链表若至少存在 1 个 chunk，那么 vicitim 指向的就是这个 chunk 的地址</strong>），是的话说明是空的，进入下一类bin的判断。</p>
</li>
<li><p>获取victim的bk，也就是上一个chunk地址赋值给bck</p>
</li>
<li><p>if判断链条的完整性，bck的下一个chunk是否是victim，不是的话报错</p>
</li>
<li><p>通过<code>set_inuse_bit_at_offset</code>将 victim 之后（进程虚拟内存中紧挨着 victim 地址的 chunk）的一个 chunk 的 prev_inuse 设置为 1，表示 victim 这个 chunk 正在被使用。fast bin 处理过程中是没有这个操作的，因为 fast bin 中的 chunk 默认都设置了 prev_inuse 的值，从而防止 chunk 之间的前后合并</p>
</li>
<li><p>然后进行一个脱链操作，<strong>注意，small bin和unsorted bin都是头进尾出。</strong></p>
</li>
<li><p>if判断这个 chunk 的分配区是否为主分配区，若是，则设置相应字段的值</p>
</li>
<li><p>接着调用<code>check_malloced_chunk</code>进行一些字段的检查</p>
</li>
</ul>
</li>
</ul>
<p><strong>黄色方框：</strong></p>
<p>这部分代码都是启用tcache bin时才会执行的部分。总体和fast bin的部分功能相同，这里只介绍一些不同的地方。</p>
<ul>
<li><p>small bin 中的 chunk 放入 tcache bin 中时需要设置 prev_inuse；fast bin 中的 chunk 默认是设置了的</p>
</li>
<li><p>small bin 断链进行的是双链表操作；fast bin 是单链表操作</p>
</li>
<li><p>small bin 需要判断是否为主分配区，并设置相应字段；fast bin 没有</p>
</li>
</ul>
<p><strong>红色方框：</strong></p>
<p>这部分和fast bin相同，将分配的好的 chunk 初始化后返回给用户</p>
<h2 id="Unsorted-Bin-处理流程"><a href="#Unsorted-Bin-处理流程" class="headerlink" title="Unsorted Bin 处理流程"></a>Unsorted Bin 处理流程</h2><p>如果在 small bin 或者 fast bin 处理流程中找到了合适大小的 chunk，那么程序就返回了。<strong>如果执行到这里，说明 chunk 大小位于 large bin 中或者在 small bin 和 fast bin 中没有找到所需大小的块</strong></p>
<h3 id="idx赋值"><a href="#idx赋值" class="headerlink" title="idx赋值"></a>idx赋值</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_1.png"></p>
<p>这个else是对应前面的<code>if (in_smallbin_range(nb))</code>，所以说明chunk大小属于large bin</p>
<ul>
<li><p>通过宏<code>largebin_index</code>获取所需 chunk 在 large bin 中的 index，即所在的 bin 链</p>
</li>
<li><p>判断 fast bin 是否存在（即是否已经初始化），若存在，则调用<code>malloc_consolidate()</code>将 fast bin 中的所有 chunk free 掉并与前后的块合并，然后存到 unsorted bin 中</p>
</li>
</ul>
<p>从else出来后，又会进入有关tcache bin的处理，</p>
<ul>
<li>调用<code>csize2tidx</code>获取所需 chunk 大小在 tcache bin 中的 idx，如果 nb 的大小位于 tcache 范围内（tcache 范围涵盖了 large bin 中的前面一小部分），则将其赋值给变量 tcache_nb，且将两个变量进行赋值0，之后会讲到，这里先略过。</li>
</ul>
<h3 id="for头检查"><a href="#for头检查" class="headerlink" title="for头检查"></a>for头检查</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_2.png"></p>
<p>进入了超大的for循环，一直到__int_malloc结束，开头进行了轮数的初始化为0，用来在while循环进行判断，该while循环持续到unsorted bin结束：</p>
<ul>
<li><p>括号进行了赋值和判断，victim 表示当前 chunk，不等于bin头的话就说明不为空</p>
</li>
<li><p><strong>bck 为 unsorted bin 上 victim 的上一个 chunk，next 为 victim 的下一个 chunk</strong></p>
</li>
<li><p>然后进行五个if判断，分别为：</p>
<ul>
<li><p>前两个if检查 victim 和 next 的 size 不能小于最小的 chunksize，也不能大于所属分配区已经分配的内存大小（<strong>这里不知道为什么是大小0x10，而不是MINSZIE0x20</strong>）</p>
</li>
<li><p>检查 next 的 prev_size 是否等于 victim 的 size</p>
</li>
<li><p>检查 victim-&gt;bk-&gt;fd 是否等于 victim，保证双链表完整性；检查 victim-&gt;fd 是否等于 unsorted_chunks(av) 这是因为在每轮循环开始有 <code>victim = unsorted_chunks(av)-&gt;bk</code></p>
</li>
<li><p>检查 victim 是否设置了 prev_inuse，因为进入 unsorted bin 中的 chunk 都已经清空了该值</p>
</li>
</ul>
</li>
</ul>
<h3 id="last-reminder"><a href="#last-reminder" class="headerlink" title="last reminder"></a>last reminder</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_3.png"></p>
<p>这里是单独讨论一种特殊情况</p>
<p>在if中需要满足四个条件：</p>
<ol>
<li><p><strong>所需 chunk 的大小的范围在 small bin 中</strong></p>
</li>
<li><p>unsorted bin 中仅剩最后一个 chunk</p>
</li>
<li><p>victim是last remainder chunk，下面是之前对于这两个变量的赋值，回忆一下</p>
<ul>
<li><code>bck = victim-&gt;bk</code></li>
<li><code>victim = unsorted_chunks(av)-&gt;bk</code></li>
</ul>
</li>
<li><p>该 last remainder chunk 的 size 需大于所需 chunk 大小与 MINSIZE 之和</p>
</li>
</ol>
<p>之后就是进行一次 chunk 切割的操作，把所需大小的 chunk 返回给用户，余下的部分作为 last remainder chunk 回到 unsorted bin 中：</p>
<ol>
<li><strong>计算出 remainder_size，然后通过<code>chunk_at_offset</code>拿到分割后 remainder 的地址</strong></li>
<li>修改 unsorted bin 的fd和bk，将其指向 last remainder chunk 的位置</li>
<li>成为新的 last remainder chunk</li>
<li>将reminder的bk和fd指向unsorted bin的bin头</li>
<li><strong>如果 remainder 大小不在 small bin 范围内</strong>，就添加 fd_nextsize 与 bk_nextsize 指针</li>
<li>设置 victim 与 remainder 的标志位</li>
<li>将 victim 存储数据的地址（victim + 2*SIZE_SZ）返回给用户</li>
</ol>
<h3 id="into-tcache"><a href="#into-tcache" class="headerlink" title="into_tcache"></a>into_tcache</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_4.png"></p>
<p>首先 check 一下链表的完整性，校验成功后，会将当前的 chunk 也就是 victim 从 unsorted bin 上面摘下来，方便后续操作</p>
<p>然后判断一下，如果 victim 的 size 刚好符合申请所需的 chunk 大小，那么先设置好标志位，然后：</p>
<ul>
<li>如果开启了 tcache（glibc2.31中默认开启），并且<strong>victim size 对应的 tc_idx 所在 bin 中仍有空余位置</strong>（少于7个），那么就调用<code>tcache_put()</code>将 victim 放入到 tcache 中，且将<strong>return_cached置为1</strong>，<strong>表示找到过符合大小的chunk</strong>且放入了tcache。</li>
<li>如果对应的这条 tcache bin 已经满了，那么就直接将其返回给用户</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_5.png"></p>
<p>这步是 unsorted bin 处理的核心，它会将 unsorted bin 中遍历的 chunk 根据 size 放入对应的 small bin 或者 large bin 中，这是唯一一次将 chunk 放入 small bin 或者 large bin 的过程。</p>
<p>如果 vicitim 的 size 位于 small bin：</p>
<ol>
<li>获取该 size 在 small bin 中的 index</li>
<li>bck等于index 所在 bin 的头指针</li>
<li>fwd等于头指针后的第一个 chunk 指针</li>
<li>使用头插法将 victim 插入到 bck 与 fwd 之间的位置，相当于末尾（图片右下角四行代码）</li>
</ol>
<p>否则，即 victim 的 size 位于 large bin 时：</p>
<ol>
<li><p>获取该 size 在 large bin 中的 index</p>
</li>
<li><p>获取该 index 所在 bin 的头指针作为 bck</p>
</li>
<li><p>获取头指针后的第一个 chunk 指针作为 fwd，<strong>这里的第一个 chunk 可以理解为这条 bin 链上 size 最大的 chunk之一</strong>，相当于下图的size为132的chunk。</p>
<p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_pic_2.png"></p>
</li>
</ol>
<p>接下来3833到3879内都是讨论chunk的大小，用来与bin中最大chunk和最小的chunk进行比较，主要用来设置large bin特有的fd_nextsize和bd_nextsize，bk和fd在最后统一设置。我采用和Cataloc师傅一样的讲述逻辑，不按照执行顺序来，这部分必须了解清楚large bin的结构是怎么样的才好理解。</p>
<ol>
<li><p><strong>fwd &#x3D;&#x3D; bck</strong></p>
<ul>
<li>这部分对应着3877-3878这两行，如果bin为空的话，直接设置victim的fd_nextsize 与 bk_nextsize成自己</li>
</ul>
</li>
<li><p><strong>fwd !&#x3D; bck 且 victim_size &lt; size（bck-&gt;bk）</strong></p>
<ul>
<li><p>这部分对应着3840-3849行，情况为chunk大小&lt;最小的chunk大小，为了方便，<strong>接下来我会用大fd和大bk来指代fd_nextsize和bd_nextsize</strong>。</p>
</li>
<li><p>可以看到这部分就是单纯在大fd、bk链条中插入了victim，我们只需要搞清这个位置在哪，以及如何进行查找的即可，位置不用多想，加进来一个最小的chunk肯定是在末尾，所以小bk和fd直接和前末尾chunk相连，而大fd和bk和最小的这群chunk的第一个相连。</p>
</li>
<li><p>首先看if中bck-&gt;bk查找到的chunk，是通过小bk找见的，所以是最小的chunk之一，且是这群chunk中的最后一个chunk。</p>
</li>
<li><p><code>fwd = bck</code>，<code>bck = bck-&gt;bk</code>， 现在fwd指向bin的头指针，bck为整条链的最后一个chunk（最后四行代码会将victim插入fwd和bck之间）。</p>
</li>
<li><p><code>victim-&gt;fd_nextsize = fwd-&gt;fd;</code> victim的<strong>大fd</strong>指向<strong>链表上第一个chunk</strong>（上图的第一个132大小的chunk）<br><code>victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</code>victim的<strong>大bk</strong>指向<strong>最小chun链表的第一个chunk</strong>(size为120chunk)</p>
</li>
<li><p><code>fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code></p>
<p><strong>链表上第一个chunk的大bk</strong>和<strong>最小chun链表的第一个chunk的大fd</strong>都指向victim。</p>
</li>
</ul>
</li>
</ol>
<p>接下来3850到3858是通过wihle循环，通过大fd来从前往后，寻找第一个不大于victim_size的chunk，找到之后就判断等于和小于两种情况。</p>
<ol start="3">
<li><p><strong>fwd !&#x3D; bck 且 victim_size &#x3D;&#x3D; fwd_size</strong></p>
<ul>
<li><p>对应3859-3862,很显然，如果存在该大小的chunk了，那就没必要设置大fd和bk，直接获取该大小chunk群的第二个chunk保存到fwd。</p>
</li>
<li><p>这里就注意，如果是插入已存在的chunk大小群，是放着这群chunk的第二个的位置，这也很好理解，放第一个还得设置大fd和bk，多此一举了。</p>
</li>
</ul>
</li>
<li><p><strong>fwd !&#x3D; bck 且 victim_size &gt; fwd_size</strong></p>
<ul>
<li><p>对应3864-3871行。</p>
</li>
<li><p>很明显victm的<strong>大fd</strong>指向<strong>这个第一个小于它本身的chunk</strong>（小c），<strong>大bk</strong>指向<strong>这个小c的大bk</strong>，也就是<strong>上一个大于小c的chunk群的第一个chunk</strong>。</p>
</li>
<li><p>检查一下<strong>链表完整性</strong></p>
</li>
<li><p><strong>小c的大bk</strong>指向<strong>victim</strong>，将<strong>victim的上个大chunk</strong>指向<strong>victim自己</strong>。</p>
</li>
</ul>
<p>这部分说起来很绕，但是自己去设计插入的角度理解，就很快能看懂了，建议把自己当作编写代码的人员，这部分你会怎么写。</p>
<p>3872-3875这部分，是属于3、4情况之后都会执行的，对bck赋值等于fwd-&gt;bk，方面最后四行代码的链表插入，将victim插入bck和fwd之间。且进行了一次<strong>链表完整性检查</strong>。</p>
</li>
</ol>
<p>最后的四行代码已经多次提到，主要说倒数第五行，<code>mark_bin()</code>主要标记该bin不为空，因为刚刚放进去了一个chunk，肯定不为空了。</p>
<h3 id="tcache处理"><a href="#tcache处理" class="headerlink" title="tcache处理"></a>tcache处理</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/unsortedbin_part_6.png"></p>
<p>这部分是整个部分的末尾。</p>
<p><strong>红色方框：</strong></p>
<ul>
<li><p>如果执行过上面<strong>分类</strong>的代码就会走到这里，所以必然没有将符合大小chunk放到tcache bin中，这样的话，tcache_unsorted_count就表示没放入tcache bin中的chunk的数目，进行+1。</p>
</li>
<li><p>如果之前把chunk放到过tcache bin（<strong>return_cached&#x3D;1</strong>），开启了<code>tcache_unsorted_limit</code>（默认是 0），且<code>tcache_unsorted_count</code>大于了<code>tcache_unsorted_limit</code> 的值，就会调用 <code>tcache_get()</code>从 tcache bin 中取出符合需求的 chunk 返回给用户。（这部分一般不执行）</p>
</li>
</ul>
<p><strong>绿色方框：</strong></p>
<p>注意这部分有个大括号，闭合了前面的 while 循环，<strong>最多遍历 unsorted bin 一万次</strong>。不然一次产生了太多的 unsorted bin，然后我 malloc 一次，结果一直在这个循环里分配 unsorted bin 上面的 chunk，迟迟等不到分配的内存，所以这里会设定一个遍历的最大值</p>
<p><strong>蓝色方框</strong>：</p>
<p>最后，出了 while 循环，也就遍历完 unsorted bin 了，这时会判断一下在先前遍历时是否找到符合需求的 chunk，若找到了且被放入了 tcache bin 中，则 return_cached 会被设置，此时调用<code>tcache_get()</code>即可。至此，unsorted bin 的处理逻辑就全部结束了。若仍未找到合适的 chunk，则会继续往后执行。</p>
<h2 id="Large-Bin-处理流程"><a href="#Large-Bin-处理流程" class="headerlink" title="Large Bin 处理流程"></a>Large Bin 处理流程</h2><h3 id="通过idx寻找"><a href="#通过idx寻找" class="headerlink" title="通过idx寻找"></a>通过idx寻找</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_1.png"></p>
<p><strong>第一层校验</strong>会判断所需的 chunk 大小 nb 是否位于 small bin 范围内，这里再判断一遍的原因是 <code>bin_at</code>这个宏是根据 size 获取在 bins 中的 idx 的，<a target="_blank" rel="noopener" href="https://cata1oc.github.io/2022/06/30/%E5%A0%86%E5%9F%BA%E7%A1%8001-ptmalloc2%E5%88%9D%E6%8E%A2/">前一篇</a>我们提到，bins 中包含了 unsorted bin，small bin 以及 large bin。这里又判断一次范围是否在 small bin 也是为了确保，<code>bin_at</code> 的结果会落在 large bin 在 bins 对应的 idx 范围内</p>
<p><strong>第二层校验</strong>是确保 large bin 不为空，且 large bin 中最大的 chunk 要比所需的 chunk 要大。<code>first</code>宏用于获取 idx 所在 bin 中第一个 chunk，即当前 idx 中最大的 chunk赋值给victim。</p>
<p>接下来开始在 large bin 中寻找到最合适的那个 chunk，逻辑如下：</p>
<ol>
<li>与插入 chunk 到 large bin 中不同，这里是从最小的 chunk 开始遍历，直到找到一个 chunk 大于等于所需的 chunk 大小</li>
<li>这里有两处判断，第二处<strong>用来确保 victim 所在的相同大小的双链上至少有两个 chunk</strong>，这样我们方便把第二个 chunk，也就是 victim-&gt;fd 给分配出去。<code>victim != last(bin)</code>主要是判断该链上是否就只有一个 chunk。</li>
<li>如果这条链上存在至少 2 个 chunk，那就取第 2 个，否则就用第 1 个。然后调用<code>unlink_chunk()</code>将这个 chunk 断链，并判断切去所需大小 nb 后，余下空间是否构成一个最小 chunk：<ul>
<li>若不能，则对这个 chunk 设置并检查相应的标志位后，返回给用户</li>
<li>若能，则会切割出 nb 大小的部分，余下的部分作为 remainder 链入到 unsorted bin 中并根据大小决定是否设置 bk_nextsize &#x2F; fd_nextsize，并对 remainder 与分割出的部分分别设置标志位，将分割出的部分返回给用户。<strong>此处分割剩下的 remainder，并没有被设置为该分配区的 last remainder chunk。分析到这里为止，仅在 unsorted bin 处理逻辑中的一次分割会设置 last remainder chunk，这点需要注意</strong>。</li>
</ul>
</li>
</ol>
<h3 id="通过binmap寻找"><a href="#通过binmap寻找" class="headerlink" title="通过binmap寻找"></a>通过binmap寻找</h3><p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_2.png"></p>
<ul>
<li><p><code>++idx</code>：在前一个 bins[idx] 所表示的 large bin 中没有找到合适的块，那么就增加 idx 的值，去 bins[idx++] 去找是否有符合的块。当然，理论上 bins[idx++] 中只要存在 chunk，就一定可以满足需求</p>
</li>
<li><p><code>bin_at</code>：这个宏之前已经多次出现，就是<strong>拿到这个 idx 在 bins 对应的链表的头节点</strong>，这个头节点是一个 malloc_chunk 结构体，通过头节点的 fd&#x2F;bk 指针可以访问这个 bin 上的第一个块（对应 large bin 中最大的块）与最后一块（对应 large bin 中最小的块）</p>
</li>
<li><p>接下来 3 行相互之间有所关联，需要放在一起来看：</p>
<ul>
<li><p>首先 block，map，bit 这三个变量都是 unsigned int 类型</p>
</li>
<li><p>malloc_state 结构中有一个 binmap，它用来快速查找对应 index 所在的 bin 是否为空。这里通过 av-&gt;binmap 来访问</p>
</li>
<li><p>binmap 是个数组，长度为 4，每个元素都是一个 32 位的整数，加起来刚好是 128 位，刚好对应 bins 中的每个 bin，这 128 位可以看作是下标，若该下标的值置0，则说明 bin 为空</p>
</li>
<li><p><code>idx2block</code> 这个宏的操作是将 idx 右移 5位，即将 idx 除 32，得到一个位于 0~3 范围内的值，从而找到该下标位于 binmap 中的第几个 32 位的整数上</p>
</li>
<li><p><code>idx2bit</code> 作用是取到 idx 对应 large bin 的下标</p>
<p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/idx2bit.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>该循环持续到large bin处理的结尾，这里分两部分讲解。</p>
<p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_3.png"></p>
<ul>
<li><p>if 语句有两个条件：</p>
<ul>
<li><p>bit &gt; map：如果bit大于map说明在本block中，该map32位中，高于bit位的位置都为0，表示对应的bin都为空，无需继续检查</p>
</li>
<li><p>bit &#x3D;&#x3D; 0：通过idx2bit转化为32位的数据中，应该是31个0和一个1组成的，所以bit!&#x3D;0；</p>
</li>
</ul>
</li>
<li><p>然后进入循环，判断当前 block 的值是否为 0，即这个 block 所表示的 32 个 bin 是否都是空的，如果是空的，就找下一个 block。如果全部都为空，就跳转到后面的 use_top 中进行处理。如果不为空，那么找到该block对应的第一个bin并将 bit 置 1（0···01表示该block的第一个bin）。</p>
</li>
<li><p>while 循环里通过 bit 与 map 相与是否为 0 来判断这个 bin 是否为空。若为空，则通过<code>next_bin</code>来访问下一个 bin，这里的下一个可以理解为 <code>bins[80] -&gt; bins[81]</code> 这种形式，同时 bit 也进行左移，即移动到这个 block 里面与表示这个 bin 所在位置的下标处。</p>
</li>
<li><p>此时这个 bin 应该不是空的，但还是要判断一下。通过 <code>last</code> 获取到 bin 中的第一个元素，判断是否与自身相等，若相等，则说明 bin 为空，那么将这个 bin 在 binmap 中对应的 bit 置零，然后继续查看下一个 bin</p>
</li>
</ul>
<p><img src="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin_part_4.png"></p>
<ul>
<li><p>若不为空，直接使用victim进行分割，因为上面赋值的是last(bin)，也就上该bin上最小的chunk。</p>
</li>
<li><p>接下来的操作就和 unsorted bin 里面满足 4 个条件的那个操作，以及前面在一开始就可以找到一个合适的 large bin chunk 时的操作是类似的。就是先切割，挂到 unsorted bin 中，返回给用户这么几个操作，这里就不多赘述了。</p>
</li>
<li><p>唯一需要注意的是，<strong>若所需的 chunk 位于 small bin 的范围</strong>（在large bin处理的开头判断过一次，范围只持续在第一部分——通过idx寻找），<strong>那么这里分割后的 remainder 会被设置为 last remainder chunk。这是第二次设置 last remainder chunk 的地方。</strong></p>
</li>
</ul>
<h2 id="Top-Chunk-处理流程"><a href="#Top-Chunk-处理流程" class="headerlink" title="Top Chunk 处理流程"></a>Top Chunk 处理流程</h2><p><img src="https://fastly.jsdelivr.net/gh/DETALA/images@main/pwn/malloc&free/1680534109697use_top.png"></p>
<ul>
<li>先通过 av-&gt;top 获取到 top chunk，通过宏 <code>chunksize</code> 获取到 top chunk 的大小。然后先做一个判断，看这个 top chunk 的 size 是否超过了 av-&gt;system_mem（这个值表示系统调用时申请的内存大小）。这个判断在 unsorted bin 的处理流程开始处也进行过一次</li>
<li>接下来，则根据 top chunk 的情况分类处理：<ul>
<li>如果 top chunk 超过 nb（所需 chunk 大小） + MINSIZE，那么操作和前面 unsorted bin 与 large bin 分割类似。<strong>此处分割不会设置 last remainder chunk</strong></li>
<li>否则，如果存在 fastbin，那么先调用 <code>malloc_consolidate()</code> 将 fastbin 合并；再根据所需的 chunk 大小设置 idx 的值，然后回到死循环的开头（图中紫色大括号，对应 unsorted bin 处理流程的开始部分）再进行一轮判断</li>
<li>若上面俩都没执行，那么调用 <code>sysmalloc()</code> 通过系统调用来进行内存分配，这部分可参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/15520621.html#sysmalloc-internal_size_t-nb-mstate-av">Pwnki</a>的分析</li>
</ul>
</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p>[堆基础02：malloc源码分析](<a target="_blank" rel="noopener" href="https://cata1oc.github.io/2022/07/16/%E5%A0%86%E5%9F%BA%E7%A1%8002-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">堆基础02：malloc源码分析 | cataLoc’s Blog</a>)</p>
</li>
<li><p>[glibc 2.31 malloc与free 源码分析](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoleqi/p/15520621.html#sysmalloc-internal_size_t-nb-mstate-av">glibc 2.31 malloc与free 源码分析（持续更新） - PwnKi - 博客园</a>)</p>
</li>
</ol>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/04/09/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_ptmalloc%E5%88%9D%E6%8E%A2/" title=""><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: </span></a></section><article class="mt-6 comment-container"><script async repo="DETALA/DETALA.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/DETALA"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> DATAL 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>